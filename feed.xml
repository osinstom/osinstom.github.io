<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://osinstom.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://osinstom.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-04-03T09:09:05+00:00</updated><id>https://osinstom.github.io/feed.xml</id><title type="html">Making networks truly programmable!</title><subtitle>Making networks programmable by Tomasz Osiński </subtitle><entry><title type="html">Configuring OVS-DPDK with VM</title><link href="https://osinstom.github.io/blog/2019/configuring-ovs-dpdk-with-vm/" rel="alternate" type="text/html" title="Configuring OVS-DPDK with VM"/><published>2019-03-23T00:00:00+00:00</published><updated>2019-03-23T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2019/configuring-ovs-dpdk-with-vm</id><content type="html" xml:base="https://osinstom.github.io/blog/2019/configuring-ovs-dpdk-with-vm/"><![CDATA[<h2 id="configuring-ovs-dpdk-with-vm-for-performance-testing">Configuring OVS-DPDK with VM for performance testing</h2> <p>Recently, I work on a performance comparison between virtualization technologies. In order to made an experiment I had had to setup a test environment based on <a href="https://software.intel.com/en-us/articles/open-vswitch-with-dpdk-overview">OVS-DPDK</a> and <a href="https://www.redhat.com/en/topics/virtualization/what-is-KVM">KVM-based Virtual Machine</a>. This user guide shows how to install and configure the test scenario with OVS-DPDK and libvirt. The test scenario is presented below. According to OVS flow rules configuration we can test PHY-OVS-PHY scenario (green line) or PHY-VM-PHY scenario (red line).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/OVS-DPDK-VM/test-scenario-ovs-dpdk-480.webp 480w,/assets/img/OVS-DPDK-VM/test-scenario-ovs-dpdk-800.webp 800w,/assets/img/OVS-DPDK-VM/test-scenario-ovs-dpdk-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/OVS-DPDK-VM/test-scenario-ovs-dpdk.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The OVS-DPDK + VM scenario </div> <h3 id="prerequisites">Prerequisites</h3> <p>Before starting installation of OVS-DPDK and VMs, let’s prepare OS.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get update
sudo apt-get upgrade

sudo apt-get -y install git qemu-system-x86 python-pip fuse libfuse-dev dh-autoreconf openssl libssl-dev cmake libpcap-dev python-yaml libnuma-dev
</code></pre></div></div> <h3 id="installing-ovs-dpdk">Installing OVS-DPDK</h3> <p>Firstly, we need to install DPDK and Open vSwitch from a source code. To install DPDK run below commands:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd $HOME &amp; mkdir dpdk
cd dpdk/
wget http://fast.dpdk.org/rel/dpdk-18.11.tar.xz
tar xf dpdk-18.11.tar.xz
cd dpdk-18.11/
</code></pre></div></div> <p>Then, we need to export environment variables, which point out to DPDK..</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export DPDK_DIR=$HOME/dpdk/dpdk-18.11
export DPDK_TARGET=x86_64-native-linuxapp-gcc
export DPDK_BUILD=$DPDK_DIR/$DPDK_TARGET
</code></pre></div></div> <p>.. and install DPDK. Note that we are using special flags (<em>-g -Ofast -march=native -Q</em>) to achieve a better performance of OVS-DPDK.</p> <p><code class="language-plaintext highlighter-rouge">EXTRA_CFLAGS="-g -Ofast" make install -j T=$target CONFIG_RTE_BUILD_COMBINE_LIBS=y CONFIG_RTE_LIBRTE_VHOST=y DESTDIR=install</code></p> <p>If the installation of DPDK has been successful, you can install OVS-DPDK.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd $HOME/dpdk/
git clone https://github.com/openvswitch/ovs
cd ovs
./boot.sh
./configure CFLAGS="-g -Ofast" --with-dpdk=$DPDK_BUILD
make -j CFLAGS="-g -Ofast -march=native -Q"
sudo make install
</code></pre></div></div> <p>Now, you should be able to verify OVS-DPDK installation by using below commands:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tomek@s14-2:~$ sudo ovs-vsctl show
3bb620bf-4d6f-4ddc-94ff-03f1ff9ccc93
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tomek@s14-2:~$ sudo ovs-vswitchd --version
ovs-vswitchd (Open vSwitch) 2.11.90
DPDK 18.11.0
</code></pre></div></div> <h3 id="configuring-ovs-dpdk">Configuring OVS-DPDK</h3> <p>Firstly, let’s configure DPDK ports. Following commands inject required kernel driver (i.e. uio, igb_uio, vfio). It is up to you, which one you would like to use. In order to choose one refer to https://doc.dpdk.org/guides/linux_gsg/linux_drivers.html. For our purposes we have used <em>uiopcigeneric</em>.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd dpdk/dpdk-18.11/usertools/
sudo modprobe uio_pci_generic
</code></pre></div></div> <p>Once kernel module has been injected NICs can be attached to DPDK. Note that you need to use the <em>bus-info</em> format (e.g.0000:88:00.0). To retrieve NIC ID in the bus-info format use:</p> <p><code class="language-plaintext highlighter-rouge">lspci | grep Ethernet</code></p> <p>This command will list all interfaces along with the bus-info identifier. Then, use dpdk-devbind.py script to bind chosen interfaces with DPDK drivers.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> ./dpdk-devbind.py <span class="nt">-b</span> uio_pci_generic 0000:88:00.0
<span class="nb">sudo</span> ./dpdk-devbind.py <span class="nt">-b</span> uio_pci_generic 0000:88:00.1
</code></pre></div></div> <p>You can check if interfaces have been bound successfully using:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tomek@s14-2:~/dpdk/dpdk-18.11$ usertools/dpdk-devbind.py --status

Network devices using DPDK-compatible driver
============================================
0000:88:00.0 '82599ES 10-Gigabit SFI/SFP+ Network Connection 10fb' drv=uio_pci_generic unused=ixgbe
0000:88:00.1 '82599ES 10-Gigabit SFI/SFP+ Network Connection 10fb' drv=uio_pci_generic unused=ixgbe
</code></pre></div></div> <p>Under “Network devices using DPDK-compatible driver” you should see the list of ports, which are already bound to the DPDK-compatible driver.</p> <p>Once Ethernet interfaces have been bound to DPDK, it’s time to mount hugepages. Hugepages are contiguous regions - segments of physical memory. In order to allocate hugepages persistently I have added following parameters to GRUB_CMDLINE_LINUX_DEFAULT in <em>/etc/default/grub</em>:</p> <p><code class="language-plaintext highlighter-rouge">GRUB_CMDLINE_LINUX_DEFAULT="default_hugepagesz=1G hugepagesz=1G hugepages=16 hugepagesz=2M hugepages=2048"</code></p> <p>Then, upgrade grub and reboot a machine:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo update-grub
sudo reboot
</code></pre></div></div> <p>This configuration will take effect after every system reboot and will result in allocating 16 hugepages of the 1G size.</p> <p>After reboot, you need only to mount hugepages using:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo mkdir -p /mnt/huge
sudo mount -t hugetlbfs nodev /mnt/huge
</code></pre></div></div> <p>To validate if hugepages has been allocated properly by:</p> <p><code class="language-plaintext highlighter-rouge">grep -i huge /proc/meminfo</code></p> <p>The number of free hugepages should be less than total number of available hugepages.</p> <p>Great, the DPDK environment should be configured properly now. We can move to the configuration of OVS. Firstly initialize OVS brigde with DPDK capabilities:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl --no-wait init
sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-init=true
</code></pre></div></div> <p>The dpdk-init=true should be applied. To validate use below command, which should return the <em>true</em> value.</p> <p><code class="language-plaintext highlighter-rouge">sudo ovs-vsctl get Open_vSwitch . dpdk_initialized</code></p> <p>Now, we need to define other OVS parameters to be used by the DPDK ports. These are:</p> <ul> <li><strong>other_config:dpdk-hugepage-dir</strong> - points to a directory, where hugepages are mounted.</li> <li><strong>other_config:dpdk-socket-mem</strong> - a comma seperated list of hugepage memory, specified in MBs per NUMA node, allocated to the ovs-vswitchd to use for the DPDK dataplane</li> <li><strong>other_config:dpdk-lcore-mask</strong> - a bitmask of what CPU core to pin to non-dataplane threads of the ovs-vswitchd to.</li> <li><strong>other_config:pmd-cpu-mask</strong> - a bitmask of what CPU core to pin to the dataplane-related (Poll Mode Driver, PMD) threads of the ovs-vswitchd to. Each bit set in the bitmask result in the creating of the PMD thread.</li> <li><strong>other_config:pmd-rxq-affinity</strong> - it is set per Interface. It pins a queue of port to the given CPU core. This parameter is optional, but in some circumstances it can be used to pin a queue of port to the specific CPU core.</li> </ul> <p>The first two options are quite straightforward and can be configured with:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-socket-mem="4096M"
sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-hugepage-dir="/mnt/huge"
</code></pre></div></div> <p>Now, to configure <em>dpdk-lcore-mask</em> and <em>pmd-cpu-mask</em> we need to find out how our server is configured. In particular, we need to know how many NUMA nodes our server has and how CPU cores are allocated across NUMA nodes.</p> <p>Just to clarify, NUMA stands for Non-Uniform Memory Access. In NUMA system memory is divided into zones called nodes, which are allocated to particular CPUs or sockets. Access to memory that is local to a CPU is faster than memory connected to remote CPUs on that system. Normally, each socket on a NUMA system has a local memory node whose contents can be accessed faster than the memory in the node local to another CPU or the memory on a bus shared by all CPUs.</p> <p>Thus, in order to achieve better performance CPU cores used by OVS-DPDK should be located on the same NUMA node as DPDK ports. So, we configure OVS-DPDK with NUMA-awareness. In order to check NUMA topology on the server use:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lscpu
--- 

NUMA node0 CPU(s):     0-9,20-29
NUMA node1 CPU(s):     10-19,30-39
</code></pre></div></div> <p>In our case we have two NUMA nodes (0 and 1). The CPU cores 0-9 and 20-29 are associated with NUMA node0, while the others are associated with NUMA node1.</p> <p>Now, for the physical ports (88:00.0 and 88:00.1 in our case), which will be connected to OVS-DPDK we should check the associated NUMA node:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /sys/bus/pci/devices/0000:88:00.0/numa_node
1
cat /sys/bus/pci/devices/0000:88:00.1/numa_node
1
</code></pre></div></div> <p><strong>As our NICs are associated with the NUMA node 1 we should dedicate CPU cores in the same NUMA node to run PMD threads.</strong> From the <em>lscpu</em> command’s output we know we should use CPU cores from range 10-19 or 30-39. So, let’s configure remaining parameters (we don’t configure <em>pmd-rxq-affinity</em>):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-lcore-mask=""
sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:pmd-cpu-mask=""
</code></pre></div></div> <p>Once DPDK parameters for OVS are configured, let’s run OVS-DPDK bridge. To create OVS-DPDK bridge use type=netdev:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl add-br br0
sudo ovs-vsctl set Bridge br0 datapath_type=netdev
</code></pre></div></div> <p>And add physical ports to OVS-DPDK:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl add-port br0 ens4f0 -- set Interface ens4f0 type=dpdk \
            options:dpdk-devargs=0000:88:00.0 \
            options:n_rxq=2 \
            ofport_request=1

sudo ovs-vsctl add-port br0 ens4f1 -- set Interface ens4f1 type=dpdk \
            options:dpdk-devargs=0000:88:00.1 \
            options:n_rxq=2 \
            ofport_request=2
</code></pre></div></div> <p>In our case we want also to attach VM to OVS-DPDK, so we create also two virtual ports (type=dpdkvhostuser). These ports will be later used by VM.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl add-port br0 dpdkvhostuser0 -- set Interface dpdkvhostuser0 type=dpdkvhostuser ofport_request=3

sudo ovs-vsctl add-port br0 dpdkvhostuser1 -- set Interface dpdkvhostuser1 type=dpdkvhostuser ofport_request=4
</code></pre></div></div> <p>Then, let’s configure the OVS flow fules to push traffic to and from VM’s ports.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-ofctl del-flows br0
sudo ovs-ofctl add-flow br0 in_port=1,actions=output:3
sudo ovs-ofctl add-flow br0 in_port=2,actions=output:4
sudo ovs-ofctl add-flow br0 in_port=3,actions=output:1
sudo ovs-ofctl add-flow br0 in_port=4,actions=output:2
</code></pre></div></div> <p>To check current configuration of OVS use:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-ofctl dump-flows br0
sudo ovs-ofctl dump-ports br0
sudo ovs-vsctl show
</code></pre></div></div> <p>Great! We have OVS-DPDK up and running. Now, let’s create and run Virtual Machine..</p> <h3 id="running-kvm-machine">Running KVM machine</h3> <p>In order to configure and run VMs we will use <em>virsh</em>. Before booting the VM up we need to prepare Host OS by configuring permissions for QEMU and hugepages to be used by VM’s ports.</p> <p>Edit <strong><em>/etc/libvirt/qemu.conf</em></strong> and modify the following lines to set “root” as the value of user and group:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user = "root"
group = "root"
</code></pre></div></div> <p>Then, restart libvirt:</p> <p><code class="language-plaintext highlighter-rouge">sudo systemctl restart libvirtd.service</code></p> <p>Now, mount hugepages to be used by QEMU:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo mkdir -p /dev/hugepages/libvirt
sudo mkdir -p /dev/hugepages/libvirt/qemu
sudo mount -t hugetlbfs hugetlbfs /dev/hugepages/libvirt/qemu
</code></pre></div></div> <p>Once done, we can run VM by using <em>virsh</em> and XML configuration file. I have prepared the pre-defined VM (testpmd.qcow2) with DPDK installed on. Moreover, I have prepared the user-data.img image with cloud init configuration, which configures password to login into VM. In order to generate user-data.img you can create a text file with the below content:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#cloud-config
password: Password1
chpasswd: { expire: False }
ssh_pwauth: True
</code></pre></div></div> <p>And generate .img file:</p> <p><code class="language-plaintext highlighter-rouge">cloud-localds user-data.img user-data</code></p> <p>Now, let’s create the XML file (let’s name it <em>demovm.xml</em>) for virsh. Refer to the XML file provided below. It will run the KVM machine with 8GB or RAM and 8 vCPUs. The VM will be attached to the OVS-DPDK ports. Note that you need to set the path to the OS image and user-data.img under the <disk> section.</disk></p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;domain</span> <span class="na">type=</span><span class="s">'kvm'</span><span class="nt">&gt;</span>
  <span class="nt">&lt;name&gt;</span>demovm<span class="nt">&lt;/name&gt;</span>
  <span class="nt">&lt;uuid&gt;</span>4a9b3f53-fa2a-47f3-a757-dd87720d9d1d<span class="nt">&lt;/uuid&gt;</span>
  <span class="nt">&lt;memory</span> <span class="na">unit=</span><span class="s">'KiB'</span><span class="nt">&gt;</span>8388608<span class="nt">&lt;/memory&gt;</span>
  <span class="nt">&lt;currentMemory</span> <span class="na">unit=</span><span class="s">'KiB'</span><span class="nt">&gt;</span>8399608<span class="nt">&lt;/currentMemory&gt;</span>
  <span class="nt">&lt;memoryBacking&gt;</span>
    <span class="nt">&lt;hugepages&gt;</span>
      <span class="nt">&lt;page</span> <span class="na">size=</span><span class="s">'1'</span> <span class="na">unit=</span><span class="s">'G'</span> <span class="na">nodeset=</span><span class="s">'0'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/hugepages&gt;</span>
  <span class="nt">&lt;/memoryBacking&gt;</span>
  <span class="nt">&lt;vcpu</span> <span class="na">placement=</span><span class="s">'static'</span><span class="nt">&gt;</span>8<span class="nt">&lt;/vcpu&gt;</span>
  <span class="nt">&lt;cputune&gt;</span>
    <span class="nt">&lt;shares&gt;</span>4096<span class="nt">&lt;/shares&gt;</span>
    <span class="nt">&lt;vcpupin</span> <span class="na">vcpu=</span><span class="s">'0'</span> <span class="na">cpuset=</span><span class="s">'14'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;vcpupin</span> <span class="na">vcpu=</span><span class="s">'1'</span> <span class="na">cpuset=</span><span class="s">'15'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;emulatorpin</span> <span class="na">cpuset=</span><span class="s">'11,13'</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/cputune&gt;</span>
  <span class="nt">&lt;os&gt;</span>
    <span class="nt">&lt;type</span> <span class="na">arch=</span><span class="s">'x86_64'</span> <span class="na">machine=</span><span class="s">'pc'</span><span class="nt">&gt;</span>hvm<span class="nt">&lt;/type&gt;</span>
    <span class="nt">&lt;boot</span> <span class="na">dev=</span><span class="s">'hd'</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/os&gt;</span>
  <span class="nt">&lt;features&gt;</span>
    <span class="nt">&lt;acpi/&gt;</span>
    <span class="nt">&lt;apic/&gt;</span>
  <span class="nt">&lt;/features&gt;</span>
  <span class="nt">&lt;cpu</span> <span class="na">mode=</span><span class="s">'host-model'</span><span class="nt">&gt;</span>
    <span class="nt">&lt;model</span> <span class="na">fallback=</span><span class="s">'allow'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;topology</span> <span class="na">sockets=</span><span class="s">'2'</span> <span class="na">cores=</span><span class="s">'4'</span> <span class="na">threads=</span><span class="s">'1'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;numa&gt;</span>
      <span class="nt">&lt;cell</span> <span class="na">id=</span><span class="s">'0'</span> <span class="na">cpus=</span><span class="s">'0-1'</span> <span class="na">memory=</span><span class="s">'4194304'</span> <span class="na">unit=</span><span class="s">'KiB'</span> <span class="na">memAccess=</span><span class="s">'shared'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/numa&gt;</span>
  <span class="nt">&lt;/cpu&gt;</span>
  <span class="nt">&lt;on_poweroff&gt;</span>destroy<span class="nt">&lt;/on_poweroff&gt;</span>
  <span class="nt">&lt;on_reboot&gt;</span>restart<span class="nt">&lt;/on_reboot&gt;</span>
  <span class="nt">&lt;on_crash&gt;</span>destroy<span class="nt">&lt;/on_crash&gt;</span>
  <span class="nt">&lt;devices&gt;</span>
    <span class="nt">&lt;emulator&gt;</span>/usr/bin/qemu-system-x86_64<span class="nt">&lt;/emulator&gt;</span>
    <span class="nt">&lt;disk</span> <span class="na">type=</span><span class="s">'file'</span> <span class="na">device=</span><span class="s">'disk'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">'qemu'</span> <span class="na">type=</span><span class="s">'qcow2'</span> <span class="na">cache=</span><span class="s">'none'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;source</span> <span class="na">file=</span><span class="s">'/home/tomek/testpmd.qcow2'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;target</span> <span class="na">dev=</span><span class="s">'vda'</span> <span class="na">bus=</span><span class="s">'virtio'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/disk&gt;</span>
    <span class="nt">&lt;disk</span> <span class="na">type=</span><span class="s">'file'</span> <span class="na">device=</span><span class="s">'disk'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;source</span> <span class="na">file=</span><span class="s">'/home/tomek/user-data.img'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;target</span> <span class="na">dev=</span><span class="s">'vdb'</span> <span class="na">bus=</span><span class="s">'virtio'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/disk&gt;</span>
    <span class="nt">&lt;interface</span> <span class="na">type=</span><span class="s">'vhostuser'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;mac</span> <span class="na">address=</span><span class="s">'00:00:00:00:00:01'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;source</span> <span class="na">type=</span><span class="s">'unix'</span> <span class="na">path=</span><span class="s">'/usr/local/var/run/openvswitch/dpdkvhostuser0'</span> <span class="na">mode=</span><span class="s">'client'</span><span class="nt">/&gt;</span>
       <span class="nt">&lt;model</span> <span class="na">type=</span><span class="s">'virtio'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;driver</span> <span class="na">queues=</span><span class="s">'2'</span><span class="nt">&gt;</span>
        <span class="nt">&lt;host</span> <span class="na">mrg_rxbuf=</span><span class="s">'off'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;/driver&gt;</span>
    <span class="nt">&lt;/interface&gt;</span>
    <span class="nt">&lt;interface</span> <span class="na">type=</span><span class="s">'vhostuser'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;mac</span> <span class="na">address=</span><span class="s">'00:00:00:00:00:02'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;source</span> <span class="na">type=</span><span class="s">'unix'</span> <span class="na">path=</span><span class="s">'/usr/local/var/run/openvswitch/dpdkvhostuser1'</span> <span class="na">mode=</span><span class="s">'client'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;model</span> <span class="na">type=</span><span class="s">'virtio'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;driver</span> <span class="na">queues=</span><span class="s">'2'</span><span class="nt">&gt;</span>
        <span class="nt">&lt;host</span> <span class="na">mrg_rxbuf=</span><span class="s">'off'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;/driver&gt;</span>
    <span class="nt">&lt;/interface&gt;</span>
    <span class="nt">&lt;serial</span> <span class="na">type=</span><span class="s">'pty'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;target</span> <span class="na">port=</span><span class="s">'0'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/serial&gt;</span>
    <span class="nt">&lt;console</span> <span class="na">type=</span><span class="s">'pty'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;target</span> <span class="na">type=</span><span class="s">'serial'</span> <span class="na">port=</span><span class="s">'0'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/console&gt;</span>
  <span class="nt">&lt;/devices&gt;</span>
<span class="nt">&lt;/domain&gt;</span>
</code></pre></div></div> <p>Once created, let’s run the KVM machine using virsh:</p> <p><code class="language-plaintext highlighter-rouge">virsh create demovm.xml</code></p> <p>Now, you can enter the console using:</p> <p><code class="language-plaintext highlighter-rouge">virsh console demovm</code></p> <p>When the VM will boot up you can login by using username: <em>ubuntu</em> and password: <em>Password1</em>.</p> <p>If you would like to test network performance of OVS-DPDK + VM deployment I recommend you to run testpmd app inside VM.</p> <p><a href="https://doc.dpdk.org/guides/testpmd_app_ug/build_app.html">Once the testpmd app is compiled</a>, let’s setup the DPDK ports inside VM and run testpmd:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo sysctl vm.nr_hugepages=1024
sudo mkdir -p /dev/hugepages
sudo mount -t hugetlbfs hugetlbfs /dev/hugepages
sudo modprobe uio
sudo insmod $DPDK_BUILD/kmod/igb_uio.ko
$DPDK_DIR/usertools/dpdk-devbind.py --status
sudo $DPDK_DIR/usertools/dpdk-devbind.py -b igb_uio 00:02.0 00:03.0
</code></pre></div></div> <p>Finally, let’s run the testpmd app, which will forward the traffic between two DPDK ports:</p> <p><code class="language-plaintext highlighter-rouge">sudo ./testpmd -n 4 --socket-mem 512 -- --burst=64 -i</code></p> <h3 id="summary">Summary</h3> <p>This post describes how to setup OVS-DPDK with VM. I hope it will be found useful for anyone, who will need to run OVS-DPDK with KVM. With this setup I was able to achieve about 8.5 Mpps (~7.5 Gbps) for small (74 Bytes) packets on HP ProLiant DL380 Gen9 server with 2x Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz and 128 GB RAM.</p> <p>If you have any question regarding the configuration process or you faced a problem to reproduce the steps don’t hesitate to contact me.</p>]]></content><author><name></name></author><category term="tutorial"/><category term="NFV"/><category term="OVS-DPDK"/><category term="Performance"/><category term="DPDK"/><category term="Linux"/><summary type="html"><![CDATA[Configuring OVS-DPDK with VM for performance testing]]></summary></entry><entry><title type="html">MPLS network based on P4</title><link href="https://osinstom.github.io/blog/2019/mpls-p4/" rel="alternate" type="text/html" title="MPLS network based on P4"/><published>2019-03-03T00:00:00+00:00</published><updated>2019-03-03T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2019/mpls-p4</id><content type="html" xml:base="https://osinstom.github.io/blog/2019/mpls-p4/"><![CDATA[<p>In the previous post I described the implementation of the IP router in the P4 language. Now, I would like to move to a little bit more advanced technology - MPLS (Multi Protocol Label Switching). This post describes the demo of MPLS implemented in P4. The demo is avaiable <a href="https://github.com/P4-Research/p4-demos/tree/master/mpls">on my GitHub</a>. Note that the demo is just a Proof of Concept and the scenario may differ from the way how MPLS works in a real-world network.</p> <h3 id="introduction-to-mpls">Introduction to MPLS</h3> <p>MPLS is widely used in the Wide Area Networks (WANs) to provide reliable connections. An explanation of the MPLS protocol is out of the scope of this post. However, I was basing on <a href="http://www.csc.kth.se/utbildning/kth/kurser/DD2490/ipro1-11/lectures/MPLS.pdf">this presentation</a>.</p> <h3 id="the-demo-scenario">The demo scenario</h3> <p>You can find the user guide and the source code of this demo <a href="https://github.com/P4-Research/p4-demos/tree/master/mpls">on my GitHub</a></p> <p>The test network (presented below) is composed of three routers and two end hosts - each associated to the different network. Hosts are attached to the devices (R1 and R3), which play the role of the edge MPLS router. The R2 router is the core MPLS router - it forwards packets based on the MPLS label. Packets from hosts are encapsulated to MPLS (and decapsulated from MPLS) by the edge routers.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/MPLS-P4/mpls-network-480.webp 480w,/assets/img/MPLS-P4/mpls-network-800.webp 800w,/assets/img/MPLS-P4/mpls-network-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/MPLS-P4/mpls-network.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The test MPLS network </div> <h3 id="the-design-of-the-mpls-router-in-p4">The design of the MPLS router in P4</h3> <p>MPLS is a standard to simplify IP forwarding. Devices implementing MPLS are called Label Switching Router (LSR). LSRs use label to set up MPLS tunnel. The basic set of LSR’s functionalities consists of:</p> <ul> <li><strong>FEC (Forwarding Equivalence Class) classifier</strong>, which classifies packets into different classes and binds a label to particular class of packets.</li> <li><strong>Label operations</strong>: <ul> <li>Push a label - add the MPLS header to a packet</li> <li>Swap a label - change a value of MPLS label</li> <li>Pop a label - remove the MPLS header from a packet</li> </ul> </li> <li><strong>Label-based forwarding</strong> - LSR determines the output port for a packet based on the input port and MPLS label.</li> </ul> <p>Besides, LSR must implement also IP lookup to forward non-MPLS packets (or when the MPLS header is stripped out) and MAC-level switching.</p> <p>The P4 program implementing MPLS is composed of 5 Match-Action tables:</p> <ul> <li><strong>fec_table</strong> - it implements a functionality of FEC classifier. We assume classification based on destination IP address (LPM), but the classification could be more granular. If a packet is classified, the push_mpls() method is invoked to add the MPLS header.</li> <li><strong>mpls_table</strong> - this table is used by transit or egress LSR. It determines to swap or pop the MPLS label based on the input port and MPLS label.</li> <li><strong>mplslookup_table</strong> - it forwards a packet to an output port based on the MPLS label (if exists).</li> <li><strong>iplookup_table</strong> - if the MPLS label doesn’t exists (it’s pure IP packet or MPLS label has been stripped out in the mpls_table) it performs IP lookup to determine the output port.</li> <li><strong>switching_table</strong> - it rewrites source and destination MAC addresses (per-hop behaviour).</li> </ul> <p>Such design of the MPLS program aggregates all MPLS functionalities in the single P4 program. It means that the one subset of functionalities will be used by the core MPLS router and the different subset will be used by the edge MPLS router. The set of functionalities used by the MPLS router is configured by installing table entries.</p> <h3 id="the-p4-code">The P4 code</h3> <p>In this section I will go through the P4 code implementing MPLS.</p> <p>Let’s start from a definition of the MPLS header:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>header_type mpls_t {
    fields {
        label : 20;
        tc : 3; // traffic class field
        bos : 1; // indicates if it's bottom of MPLS label's stack
        ttl: 8;
    }
}
</code></pre></div></div> <p>It is composed of four fields. The most important is the label field, which is dedicated to store the tunnel identifier.</p> <p>The MPLS header is extracted based on etherType by the P4 parser:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define ETHERTYPE_MPLS 0x8847
(...)
parser parse_ethernet {
    extract(ethernet);
    return select(latest.etherType) {
        ETHERTYPE_IPV4 : parse_ipv4;
        ETHERTYPE_MPLS : parse_mpls;
        default: ingress;
    }
}
</code></pre></div></div> <p>When extracted, packets are passed to the <em>ingress</em> pipeline. The pipeline defines the order of Match-Action tables that will handle packets.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>control ingress {
    apply(fec_table);
    apply(mpls_table);
    apply(mplslookup_table);
    if (standard_metadata.egress_spec == 0) {
        apply(iplookup_table);
    }
    apply(switching_table);
}
</code></pre></div></div> <p>Match-Action tables make use of the pre-defined MPLS actions: <em>push_mpls()</em>, <em>pop_mpls()</em> and <em>swap_mpls()</em>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>action push_mpls(label) {
    add_header(mpls);
    modify_field(mpls.label, label);
    modify_field(mpls.tc, 7);
    modify_field(mpls.bos, 0x1);
    modify_field(mpls.ttl, 32);
    modify_field(ethernet.etherType, ETHERTYPE_MPLS);
}

action pop_mpls() {
    remove_header(mpls);
    modify_field(ethernet.etherType, ETHERTYPE_IPV4);
}

action swap_mpls(label) {
   modify_field(mpls.label, label);
   subtract_from_field(mpls.ttl, 1);
}
</code></pre></div></div> <p>The <em>push_mpls()</em> action adds the MPLS header to a packet and sets a value of MPLS fields. Moreover, it modifies etherType to indicate the MPLS protocol. The <em>pop_mpls()</em> action removes the MPLS header and reverts a value of etherType to indicate the IPv4 protocol. The <em>swap_mpls()</em> action just changes a value of the MPLS label and decrements a value of TTL.</p> <p>The first table that handles incoming packets is the <em>fec_table</em>. It classifies packets (based on the destination IP address) to the MPLS class (tunnel). If classified, a packet may be encapsulated by using the <em>push_mpls()</em> action.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table fec_table {

    reads {
        ipv4.dstAddr : lpm;
    }

    actions {
        push_mpls;
        _drop;
    }
}
</code></pre></div></div> <p>The <em>mpls_table</em> is used to handle MPLS packets. It reads an input port and the MPLS label and decides to pop or swap the MPLS label.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table mpls_table {

    reads {
        standard_metadata.ingress_port: exact;
        mpls.label : exact;
    }

    actions {
        pop_mpls;
        swap_mpls;
        _drop;
    }
}
</code></pre></div></div> <p>When a label is set packets enter <em>mplslookup_table</em>, which determines an output port based on the MPLS label.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table mplslookup_table {

    reads {
        mpls.label : exact;
    }

    actions {
        forward;
        _drop;
    }
}
</code></pre></div></div> <p>The last two tables - <em>iplookup_table</em> and <em>switching_table</em> - implement IP routing and MAC rewriting, respectively. The former is used to determine an output port for IP packets (e.g. when packets are decapsulated from MPLS). The latter rewrites MAC addresses hop-by-hop.</p> <h3 id="summary">Summary</h3> <p>In this post I described how to implement MPLS in the P4 language. The MPLS implementation is fairly straightforward and is much easier than writing the code in C, what’s a big advantage of the P4 language! In order to reproduce an experiment follow the steps listed in <a href="https://github.com/P4-Research/p4-demos/tree/master/mpls">the user guide</a>.</p>]]></content><author><name></name></author><category term="tutorial"/><category term="SDN"/><category term="BMv2"/><category term="NFV"/><category term="Python"/><category term="Mininet"/><category term="MPLS"/><summary type="html"><![CDATA[In the previous post I described the implementation of the IP router in the P4 language. Now, I would like to move to a little bit more advanced technology - MPLS (Multi Protocol Label Switching). This post describes the demo of MPLS implemented in P4. The demo is avaiable on my GitHub. Note that the demo is just a Proof of Concept and the scenario may differ from the way how MPLS works in a real-world network.]]></summary></entry><entry><title type="html">IP Router in P4</title><link href="https://osinstom.github.io/blog/2019/ip-router-p4/" rel="alternate" type="text/html" title="IP Router in P4"/><published>2019-02-11T00:00:00+00:00</published><updated>2019-02-11T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2019/ip-router-p4</id><content type="html" xml:base="https://osinstom.github.io/blog/2019/ip-router-p4/"><![CDATA[<p>In the previous post I introduced P4 and tools to implement network prototypes. Now, I would like to show a basic example how to use this tools in practice to run an experiment.</p> <p>I prepared a demo of IP routing to show how simply someone can prototype a commonly used technology. The demo is based on P4 and Mininet. The source code and user guide is available at https://github.com/osinstom/p4-demos/tree/master/ip-routing.</p> <p>The README file contains a description of a P4 program’s design as well as a topology of a test network. Below I summarize a design choices that I made:</p> <ul> <li>I have used <strong>P4_16</strong> as it is the newest version of P4.</li> <li>As the P4 target I use <strong>BMv2</strong> (https://github.com/p4lang/behavioral-model)</li> <li>The <strong>P4_16</strong> introduces the concept of architecture model for target device. I have used <strong>V1Model</strong> (https://github.com/p4lang/p4c/blob/master/p4include/v1model.p4), which is a defualt one for BMv2</li> <li>The V1Model forces us to implement the <strong>Ingress</strong> and <strong>Egress</strong> control blocks, <strong>Parser</strong>, <strong>Deparser</strong> and methods to handle checksum (verifyChecksum and computeChecksum). For the sake of demo I don’t focus on checksum operations.</li> <li>Design choices for the <strong>router.p4</strong> program: <ul> <li>I defined Ethernet and IPv4 headers (only)</li> <li>I defined additional metadata struct called <strong>routing_metadata</strong>. It is used to pass a routing decision made in the Ingress block to the Egress block. In the Egress block it will be used to determine the MAC address of the next-hop.</li> <li>The Parser Logic handles only Ethernet and IPv4 headers (e.g. ARP, IPv6 or VLAN is not parsed)</li> <li>For the <strong>Ingress</strong> control we defined the <strong>routing_table</strong>. This table has three actions: drop(), NoAction() and ipv4_forward(). The last action performs three operations:</li> <li>it selects output port based on the IPv4 destination LPM</li> <li>it sets a next-hop IP address in routing_metadata.</li> <li>it decrements TTL</li> <li>For the <strong>Egress</strong> control block we defined <strong>switching_table</strong> and <strong>mac_rewriting_table</strong>. The switching_table sets a destination MAC for packet based on next-hop IP from routing_metadata. The mac_rewriting_table changes the source MAC address for packet according to port, that has been selected as the output port.</li> </ul> </li> </ul> <p>If you want to know basics of how P4 works I encourage you to follow a user guide and test how IP routing written in P4 works. In the subsequent posts I will show another example - MPLS network written in P4.</p>]]></content><author><name></name></author><category term="tutorial"/><category term="SDN"/><category term="BMv2"/><category term="NFV"/><category term="Python"/><category term="IP"/><category term="Router"/><summary type="html"><![CDATA[In the previous post I introduced P4 and tools to implement network prototypes. Now, I would like to show a basic example how to use this tools in practice to run an experiment.]]></summary></entry><entry><title type="html">Network prototyping made easy with P4 and Python!</title><link href="https://osinstom.github.io/blog/2018/network-prototyping-p4/" rel="alternate" type="text/html" title="Network prototyping made easy with P4 and Python!"/><published>2018-12-24T00:00:00+00:00</published><updated>2018-12-24T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2018/network-prototyping-p4</id><content type="html" xml:base="https://osinstom.github.io/blog/2018/network-prototyping-p4/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>Have you ever tried to understand deeply mechanisms of network protocols? I mean network protocols used by computer networks like, for example, Internet Protocol (IP), Transmission Control Protocol (TCP) or Spanning Tree Protocol (STP). Students are taught at university how network systems works. Next, they become network administrators, developers or architects. They know how to configure network devices, design complex systems or develop network algorithms. However, it is likely that they got their knowledge from books and/or administration courses, not from development practice! On the other hand, I think the best way to understand network paradigms quickly and deeply is to implement network mechanisms on your own. If as a student you get the deep knowledge about networking basics, it will be easier to understand novel technologies in the future. So far, it was required to use some low-level programming languages (C/C++) with thousands lines of code to build network’s prototype. And here comes the P4 technology and Python as a solution to prototype networks in the easy and fast way! Combining P4 with tools provided by Python such as the Scapy library or Mininet gives unlimited possibilities to implement, build and test complex network systems. Moreover, you can prototype network protocols, which don’t even exist yet!</p> <h2 id="p4-python-scapy-and-mininet--the-toolset-of-network-researcher">P4, Python (Scapy) and Mininet – the toolset of network researcher</h2> <p>I assume you know already what the Python language is, but what is P4? P4 stands for Programming Protocol-Independent Packet Processors. It has been developed as a next step in the evolution of Software-Defined Networking (SDN). As you may know, the classical telecommunications architecture can be divided into data plane, control plane and management plane. Data plane is the layer, where data packets are being processed and forwarded, while the control plane decides how these packets should be handled. <strong>P4 has been designed to enable data plane programming.</strong> Thus, using the P4 language you can specify which packet’s headers can be processed and which actions can be performed on packets. The data plane programming was the missing link in the software-based network systems, where control plane and management plane are programmable already. Currently, a network system can be defined completely using software and its behaviour can be changed dynamically by updating the software version. It brings a lot of flexibility to the networking world!</p> <p>The main component of the P4 ecosystem is the P4 language. It is a high-level Domain-Specific Language (DSL) dedicated for programming of network devices. It allows to specify the format of packets (protocol’s headers) to be recognized by network devices and actions to be performed on incoming packets (forwarding, headers modification, adding protocol header, etc). Nevertheless, the P4 language is not consumed directly by the network device, but it must be compiled to the source code for particular platform (some target-specific binary). These platforms are hardware-based (e.g. Barefoot Tofino, <a href="https://p4.org/p4/p4-netfpga-a-low-cost-solution-for-testing-p4-programs-in-hardware.html">FPGA</a>) or software-based (e.g. <a href="https://github.com/p4lang/behavioral-model">BMv2</a>, <a href="https://github.com/vmware/p4c-xdp">eBPF/XDP</a>, <a href="http://pisces.cs.princeton.edu/">PISCES</a> or <a href="https://github.com/Orange-OpenSource/p4rt-ovs">P4rt-OVS</a>). The goal of P4 is to become the same what the CUDA language became for graphics cards programming. The concept of the P4 language has been presented below.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/network-prototyping-p4/p4-program-structure-480.webp 480w,/assets/img/network-prototyping-p4/p4-program-structure-800.webp 800w,/assets/img/network-prototyping-p4/p4-program-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/network-prototyping-p4/p4-program-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Example of P4 program structure </div> <p>The P4 program is composed of three main sections: Protocols definition (data declaration), Parser Logic (Parser &amp; Deparser) and a number of control blocks containing Match-Action tables. The first section defines the protocols headers that the network device will be able to recognize. For instance, defining IPv4 header is as simple as:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>header ipv4_t {
    bit&lt;4&gt;    version;
    bit&lt;4&gt;    ihl;
    bit&lt;8&gt;    diffserv;
    bit&lt;16&gt;   totalLen;
    bit&lt;16&gt;   identification;
    bit&lt;3&gt;    flags;
    bit&lt;13&gt;   fragOffset;
    bit&lt;8&gt;    ttl;
    bit&lt;8&gt;    protocol;
    bit&lt;16&gt;   hdrChecksum;
    bit&lt;32&gt; srcAddr;
    bit&lt;32&gt; dstAddr;
}
</code></pre></div></div> <p>The programmer just needs to declare header fields and their length. That’s all. Now, these headers are used to parse incoming data and recognize type of packets. The Parser Logic is a finite state machine defining the steps to read and parse incoming packets. Visually, the Parser can be represented as a cyclic graph, in which every node processes a protocol’s header.</p> <p>The P4 code implementing the Parser for simple IPv4 router is as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parser RouterParser(packet_in packet,
                    out headers hdr,
                    inout metadata meta,
                    inout standard_metadata_t standard_metadata) {
     state start {
         transition parse_ethernet;
     }
     state parse_ethernet {
         packet.extract(hdr.ethernet);
         transition select(hdr.ethernet.etherType) {
             TYPE_IPV4: parse_ipv4;
             default: accept;
          }
     }
     state parse_ipv4 {
         packet.extract(hdr.ipv4);
         transition accept;
     }
}
</code></pre></div></div> <p>Furthermore, in the P4 program programmer must define a number of control blocks, which contains Match-Action tables. The definition of simple IPv4 forwarding table can be implemented as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table routing_table {
    key = {
        hdr.ipv4.dstAddr: lpm;
    }
    actions = {
       ipv4_forward;
       drop;
       NoAction;
    }
    default_action = NoAction();
}
</code></pre></div></div> <p>The above routing_table reads the IPv4 destination IP address and matches it based on the Longest Prefix Match algorithm. Then, on packets matching the rule there can be three actions performed: ipv4_forward, drop or NoAction.</p> <p>The last part is to define the Deparser, which defines the order of packet’s headers for outgoing packets.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>control deparser(packet_out packet,
                 in headers hdr) {

    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}
</code></pre></div></div> <p>If you would like to view the complete example of IP router written in P4 visit <a href="https://github.com/osinstom/p4-demos/blob/master/ip-routing/p4include/router.p4">my GitHub repository</a>.</p> <p>So, as I pointed out, the P4 language can be used to implement any type of data plane protocols. Although, <a href="https://blogs.vmware.com/research/2017/04/07/programming-networks-p4/">it has some limitations</a> it is a powerful technology that can be used by network researchers to prototype and test novel network protocols. Creativity is the limit! To learn more on P4, let’s visit:</p> <p><a href="https://www.networkworld.com/article/3163496/cloud-computing/what-p4-programming-is-and-why-it-s-such-a-big-deal-for-software-defined-networking.html">What P4 programming is and why it’s such a big deal for Software-Defined Networking?</a></p> <p><a href="https://p4.org/assets/P4_tutorial_01_basics.gslide.pdf">P4 tutorial – presentation</a></p> <p><a href="https://cs344-stanford.github.io/deliverables/p4-mininet/">P4 tutorial from Stanford</a></p> <p><a href="https://github.com/p4lang/tutorials">P4 tutorials – GitHub repo</a></p> <p><a href="https://www.sigcomm.org/sites/default/files/ccr/papers/2014/July/0000000-0000004.pdf">P4: Programming Protocol-independent Packet Processors</a></p> <p>Ok, P4 gives the tool to program the data plane, but what about a control plane? In fact, you can use any language to listen to the packets being sent from data plane. However, I believe the most simple to use is Python. It comes with the library named scapy. Scapy allows you to parse network packets received on sockets as well as construct new packets as simply as in the below example:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">IP</span><span class="p">()</span><span class="o">/</span><span class="nc">TCP</span><span class="p">()</span><span class="o">/</span><span class="sh">"</span><span class="s">AAAA</span><span class="sh">"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span>
<span class="o">&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">summary</span><span class="p">()</span>
<span class="sh">'</span><span class="s">IP / TCP 127.0.0.1:ftp-data &gt; 127.0.0.1:www S / Raw</span><span class="sh">'</span>
</code></pre></div></div> <p>From my experience Scapy is a user-friendly library that can be used to implement a control plane applications or generate custom packets from host devices. More on Scapy library you can read <a href="https://scapy.readthedocs.io/en/latest/introduction.html">here</a>.</p> <p>The P4 language allows us to program data plane and Python is the recommended language to implement control plane of the prototyped network. Voila! Now, the question is how to emulate the real network at scale? The BMv2 switch, which is the reference P4 software switch, is well-integrated with <a href="http://mininet.org/">Mininet</a>. Thus, you can create a virtual network of any size on your local computer! I have used Mininet for almost four years to experiment with SDN and OpenFlow – it is a very powerful tool that make life of network researcher easier!</p> <h2 id="summary">Summary</h2> <p>In this blog post I introduced useful tools for network researchers – P4, Python (Scapy) and Mininet. These technologies make network prototyping easier than ever before! P4 allows to program data plane in tens or hundreds (instead of thousands) of lines of code. Python comes with Scapy library that simplifies programming operations on network packets. Finally, Mininet provides the tool to emulate a real network on your local computer by writing a simple Python script.</p> <h3 id="references">References</h3> <p>[1] W. L. Costa Cordeıro, J. A. Marques, and L. P. Gaspary, “Data Plane Programmability Beyond OpenFlow: Opportunities and Challenges for Network and Service Operations and Management,” J. Netw. Syst. Manage., vol. 25, no. 4, pp. 784–818, Oct. 2017.</p>]]></content><author><name></name></author><category term="tutorial"/><category term="SDN"/><category term="BMv2"/><category term="NFV"/><category term="Python"/><category term="Mininet"/><category term="scapy"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Initial view on VoWiFi in the 5G network</title><link href="https://osinstom.github.io/blog/2017/vowifi-5g/" rel="alternate" type="text/html" title="Initial view on VoWiFi in the 5G network"/><published>2017-12-18T00:00:00+00:00</published><updated>2017-12-18T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2017/vowifi-5g</id><content type="html" xml:base="https://osinstom.github.io/blog/2017/vowifi-5g/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>In this post I provide a short overview of how the VoWiFi (Voice over WiFi) architecture may change in future 5G deployments. I haven’t participated in the 3GPP standardization groups, so this text is based on official 3GPP specifications and drafts only. I hope it will be valuable for engineers, who are currently working on EPC-based VoWiFi deployments and want to prepare for upcoming evolutions in the area of VoWiFi.</p> <p>VoWiFi (or simply WiFi Calling) has gained a momentum as a novel Telco service for end users as they can now make phone calls via their own home WiFi Access Point. This service is especially important for users being abroad as they can use WiFi Calling instead of making expensive roaming calls. Along with VoLTE, the IMS-based voice services may replace the old 2G/3G technology.</p> <p>An implementation of VoWiFi has become possible with the emergence of the IP Multimedia Subsystem (IMS) and extensions to 3GPP LTE EPC architecture – evolved Packet Gateway (ePDG) and the AAA server. ePDG provides a secure gateway to service provider’s networks for users connected to untrusted WiFi access points. It leverages IPSec with the EAP-AKA authentication method on SWu interface as the security protocol. The AAA server provides security services for non-3GPP access. The ePDG is integrated with the rest of LTE. It is connected to P-GW over S2b interface using GTP tunneling, while the AAA server is integrated with HSS over SWx and to PGW over S6b interface. P-GW provides access for VoWiFi users to the IMS subsystem.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/evolved_packet_core-svg-480.webp 480w,/assets/img/VoWiFi_5G/evolved_packet_core-svg-800.webp 800w,/assets/img/VoWiFi_5G/evolved_packet_core-svg-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/evolved_packet_core-svg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Source: Wikipedia </div> <p>Although the 3GPP 5GSystem (5GS) specification is still in progress (<a href="https://www.sdxcentral.com/articles/news/3gpp-delays-second-wave-of-5g-specs/2018/12/">the “Second Wave” of 5G specs has been delayed</a>), a functional architecture of 5G RAN and Core has been already defined and should not be changed significantly (<a href="https://www.riverpublishers.com/journal/journal_articles/RP_Journal_2245-800X_615.pdf">here</a> you can find an introduction to the 5G system architecture). It’s already agreed that the VoWiFi architecture will need some changes to fulfill the requirements of 5G network. One of design pricinples that has been defined for 5G networks (TS 23.501), directly impacts the VoWiFi architecture:</p> <blockquote> <p>“Minimize dependencies between the Access Network (AN) and the Core Network (CN). The architecture is defined with a converged core network with a common AN – CN interface which integrates different Access Types e.g. 3GPP access and non-3GPP access“</p> </blockquote> <p>As 5G System is expected to be access-agnostic the interface between RAN and Core should be common for access technologies. Moreover, UEs should be allowed to communicate with core network over the NAS (Non-Access Stratum) interface, regardless current point of attachment. The NAS interface is a well-known in 3GPP systems, but in the current EPC-based VoWiFi architecture UE does not perform any signalling over the NAS interface. The principle of converged core network with a common AN-CN interface causes the change in architectural design.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/5g-480.webp 480w,/assets/img/VoWiFi_5G/5g-800.webp 800w,/assets/img/VoWiFi_5G/5g-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/5g.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 5G Core Network with non-3GPP access. Source: TS 23.501 </div> <p>The 5G Core Network functions involved in the VoWiFi service are AMF, SMF, AUSF (control plane) and UPF (user plane). The Mobility Management Functions (MME) from 4G, which implements mobility, access and session management has been decomposed into AMF and SMF. AMF, which stands for Access and Mobility Function realizes access and mobility management functions, while SMF (Session Management Function) manages session connectivity. The decomposition is needed due to the emergence of new services (such as Internet of Things) requiring a differentiated session management. For instance, static IoT likely will not require session management and packets can be forwarded in the Best-Effort manner. Moreover, a control and user plane has been decoupled. Control plane functions has been moved from S-/P-GW to AMF and SMF. User plane functions (such as packet routing, forwarding, and encapsulation) are realized by UPF (User Plane Function).</p> <p>In the 5G System specification the successor of eDPG is called <strong>N3IWF (non-3GPP InterWorking Function)</strong>. The functionality of N3IWF at high-level is almost the same as ePDG – it provides a secure gateway to operator’s network for non-3GPP access technology. The interface between UE and N3IWF remains similar and is based on IPSec/IKE to establish a secure tunnel. As UE is expected to communicate with AMF over the NAS interface, there is a new N2 interface connecting N3IWF with AMF. Note that the N2 interface is considered to realized by a NG Application Protocol (NGAP) defined in TS 38.413. N3IWF is responsible for setting up the IPSec connection to be used by control plane traffic directed to AMF. As a consequence <strong>UE and N3IWF need to establish two IPSec Security Associations (SAs)</strong>:</p> <ol> <li><strong>Signalling (control plane) IPSec SA</strong> – it transports NAS messages destined to AMF,</li> <li><strong>User plane IPSec SA</strong> – it transports packets destined to IMS</li> </ol> <h2 id="signalling-control-plane-ipsec-sa">Signalling (control plane) IPSec SA</h2> <p>In the first step, UE and N3IWF must establish a signalling IPSec SA, which is used to securely exchange NAS messages between UE and AMF. The NAS interface is further leveraged to register UE in the 5G system. The below figure presents a control plane protocol’s stack used to establish signalling IPSec SA. Similarly to ePDG, IKEv2 protocol is used to setup security associations. However, the new authentication method – EAP-5G (or 5G AKA) – is introduced. The EAP method is used to encapsulate NAS messages between UE and N3IWF. Note that specification says that EAP-5G is “vendor-specific“.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_before-480.webp 480w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_before-800.webp 800w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_before-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_before.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Signalling protocol’s stack before signalling IPSec SA is established </div> <p>When the signalling IPSec SA is established, the IPSec tunnel is configured to encapsulate NAS messages between UE and N3IWF. At this stage, UE can communicate with AMF to perform NAS signalling. It is presented in the figure below.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_after-480.webp 480w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_after-800.webp 800w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_after-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_after.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Signalling protocol’s stack once signalling IPSec SA is established </div> <h2 id="user-plane-ipsec-sa">User plane IPSec SA</h2> <p>When UE is registered in the 5G system (via NAS interface) it can establish a new child IPSec SA (called user plane IPSec SA) to communicate with the IMS system. The procedure for establishing user plane IPSec SA is also supported by AMF.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_userplane_establishment-480.webp 480w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_userplane_establishment-800.webp 800w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_userplane_establishment-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_userplane_establishment.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> User plane protocol’s stack to establish user plane IPSec SA </div> <p>If IKEv2 procedure is finished, UE can communicate with P-CSCF (IMS gateway). A user plane protocol’s stack is depicted in the figure below. There are two main differences in comparison to the ePDG-based architecture:</p> <ul> <li> <p>The GRE (Generic Routing Encapsulation) protocol has been introduced to carry user data packets between UE and N3IWF. GRE allows to implement a flow-based QoS model as specified in TS 23.501. The GRE header carries QFI (QoS Flow Identifier) associated with user data packets. Optionally, N3IWF can indicate Reflective QoS Identifier (RQI). More on QoS in 5G networks <a href="https://www.linkedin.com/pulse/learn-qos-5g-networks-paul-shepherd/">here</a>.</p> </li> <li> <p>The new N3 interface between N3IWF and UPF. This interface is considered to be implemented based on GTPv2.</p> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/VoWiFI5G_userplane-480.webp 480w,/assets/img/VoWiFi_5G/VoWiFI5G_userplane-800.webp 800w,/assets/img/VoWiFi_5G/VoWiFI5G_userplane-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/VoWiFI5G_userplane.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> User plane protocol’s stack to transport user data packets </div> <h2 id="summary">Summary</h2> <p>In this post I have made a quick review of the current status of work on non-3GPP access part of the 5G network. I have presented a general architecture and protocols used to implement VoWiFi in the 5G system.</p> <p>Although the 5G specification is not completed yet, some design choices have been already made. The major changes to the VoWiFi architecture are applied on the 3GPP network side. The Non-3GPP InterWorking Function (N3IWF) has been introduced as a successor of ePDG. Generally, enhancements to the VoWiFi architecture can be summarized as follows:</p> <ul> <li><strong>Common NAS</strong> – the VoWiFi architecture has been extended with a support for NAS signalling between UE and AMF (the successor of MME). It means that UE and N3IWF establishes two IPSec SAs. Signalling IPSec SA transports NAS messages, while user plane IPSec SA carries packets (e.g. SIP signalling) destined to IMS.</li> <li><strong>Modified authentication method</strong> – the procedure establishing the IPSec tunnel is based on new authentication method – 5G AKA.</li> <li><strong>Protocol enhancements</strong> – the EAP-5G protocol is used to encapsulate NAS messages between UE and N3IWF. Additionally, the GRE protocol is used to encapsulate user-plane traffic.</li> </ul> <h3 id="references">References</h3> <p>[1] 3GPP TS 23.501</p> <p>[2] 3GPP TS 24.502</p> <p>[3] <a href="https://docbox.etsi.org/workshop/2018/201806_ETSISECURITYWEEK/5G/S01_INPUT_TO_5G/5G_ENHANCEMENTS_NON3GPP_ACCSEC_LENOVO_KUNZ.pdf">5G Enhancements to Non – 3GPP Access Security</a></p>]]></content><author><name></name></author><category term="article"/><category term="5G"/><category term="3GPP"/><category term="ePDF"/><category term="N3IWF"/><category term="SIP"/><category term="IPSec"/><category term="IKE"/><summary type="html"><![CDATA[A short overview of how the Voice over WiFi architecture may change in 5G deployments compared to 4G.]]></summary></entry><entry><title type="html">Explanation of IPSec basics</title><link href="https://osinstom.github.io/blog/2017/ipsec-explanation/" rel="alternate" type="text/html" title="Explanation of IPSec basics"/><published>2017-11-21T00:00:00+00:00</published><updated>2017-11-21T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2017/ipsec-explanation</id><content type="html" xml:base="https://osinstom.github.io/blog/2017/ipsec-explanation/"><![CDATA[<p>In my first post on this blog I encourage you to watch my YouTube tutorial about IPSec, which I made some time ago. The tutorial is a practical guide based on Strongswan, an open-source implementation of the IPSec stack.</p> <iframe width="560" height="315" src="https://www.youtube.com/embed/D-Esrw8wxA4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>]]></content><author><name></name></author><category term="tutorial"/><category term="IPSec"/><category term="Tutorial"/><category term="Strongswan"/><summary type="html"><![CDATA[An in-depth tutorial on IPSec based on Strongswan]]></summary></entry></feed>