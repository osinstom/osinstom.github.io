<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://osinstom.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://osinstom.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-04-03T17:19:50+00:00</updated><id>https://osinstom.github.io/feed.xml</id><title type="html">Making networks truly programmable!</title><subtitle>Making networks programmable by Tomasz Osiński </subtitle><entry><title type="html">My notes from podcast “Why doesn’t OVS support P4?”</title><link href="https://osinstom.github.io/blog/2020/my-notes-from-podcast-why-doesn-t-ovs-support-p4/" rel="alternate" type="text/html" title="My notes from podcast “Why doesn’t OVS support P4?”"/><published>2020-02-11T00:00:00+00:00</published><updated>2020-02-11T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2020/my-notes-from-podcast-why-doesn-t-ovs-support-p4</id><content type="html" xml:base="https://osinstom.github.io/blog/2020/my-notes-from-podcast-why-doesn-t-ovs-support-p4/"><![CDATA[<p>The OVS Orbit podcast “User-Configurable Protocol Support for OVS, or Why Doesn’t OVS Support P4?” [1] was recorded at the Dagstuhl seminar on programmable data planes in April 2019. It explains the reasons that OVS doesn’t already have support for P4, what’s changing, and likely future directions. There are my notes (quick summary) from this podcast below.</p> <h3 id="why-not-pisces-2">Why not PISCES [2]?</h3> <ol> <li>It is only DPDK-based. It does not support kernel datapath or HyperV.</li> <li>A bit outdated (based on the old version of OVS), but could be forward-ported.</li> <li>The main reason why it has not been integrated: Not compatible with existing OVS features. Lack of backward compatibility.</li> </ol> <h3 id="is-p4-suitable-for-software-switches">Is P4 suitable for software switches?</h3> <p>P4 is more designed for hardware, but most of the features can be realized also in software.</p> <p>What is hard in software, but easy in hardware?</p> <ul> <li>checksums - computation of them can be expensive in software. It should be done incrementally.</li> <li>a few more..</li> </ul> <p>Ben proposes to include only Parser in the P4_16 architecture model for OVS, because P4 model nicely describes hardware pipeline, but for software switches it does not make sense to specify fixed tables, what actions the table needs to have and fixed packet processing pipeline in advance.</p> <h3 id="why-is-it-hard-to-have-user-configurable-protocols-p4-support-in-ovs">Why is it hard to have user-configurable protocols (P4 support) in OVS?</h3> <ol> <li>Fixed interface between slowpath (ovs-vswitchd) and multiple datapaths. There are difficulties to make it protocol-independent.</li> <li>Version compatiblity with kernel module (not maintained by OVS)</li> </ol> <h3 id="how-we-can-implement-p4-support-in-ovs">How we can implement P4 support in OVS?</h3> <ol> <li>eBPF <ul> <li><strong>Option #1:</strong> Add OVS action that executes eBPF code</li> <li><strong>Option #2:</strong> Re-write kernel datapath in eBPF/XDP, but there are problems with it (e.g. limited number of instructions, performance, tail calls).</li> </ul> <ul> <li>In case of eBPF, restrictions of P4 language on tables (defining them in advance) can make it easier to integrate P4 with eBPF.</li> <li>eBPF is slower than OVS kernel module, but more flexible: you can tailor kernel module to user-configurable protocols.</li> </ul> </li> <li>Get rid of kernel module at all and use just packet interface (like DPDK). So far, it was not possible to get rid of kernel module because there was no fast kernel-user interface. <strong>However, there is a new packet interface called AF_XDP that provides fast kernel-user interface!</strong> <ul> <li>Disadvantage: It would be tough to force enterprise users to get rid of kernel module and use AF_XDP.</li> </ul> </li> </ol> <h3 id="references">References</h3> <p>[1] https://ovsorbit.org/#e69</p> <p>[2] Shahbaz et al., “PISCES: A Programmable, Protocol-Independent Software Switch”, ACM SIGCOMM 2016</p>]]></content><author><name></name></author><category term="article"/><category term="P4"/><category term="OVS"/><category term="PISCES"/><summary type="html"><![CDATA[The OVS Orbit podcast “User-Configurable Protocol Support for OVS, or Why Doesn’t OVS Support P4?” [1] was recorded at the Dagstuhl seminar on programmable data planes in April 2019. It explains the reasons that OVS doesn’t already have support for P4, what’s changing, and likely future directions. There are my notes (quick summary) from this podcast below.]]></summary></entry><entry><title type="html">p4c-ubpf - the new back-end for the P4 compiler!</title><link href="https://osinstom.github.io/blog/2020/p4c-ubpf-the-new-back-end-for-the-p4-compiler/" rel="alternate" type="text/html" title="p4c-ubpf - the new back-end for the P4 compiler!"/><published>2020-02-06T00:00:00+00:00</published><updated>2020-02-06T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2020/p4c-ubpf-the-new-back-end-for-the-p4-compiler</id><content type="html" xml:base="https://osinstom.github.io/blog/2020/p4c-ubpf-the-new-back-end-for-the-p4-compiler/"><![CDATA[<p>NOTE: This blog post was originally published on P4.org: https://opennetworking.org/news-and-events/blog/p4c-ubpf-a-new-back-end-for-the-p4-compiler/.</p> <hr/> <p>With the constant development of the P4 language more and more programmable targets are emerging. The P4 compiler has already support for the next-generation Linux datapath such as eBPF/XDP. However, it is sometimes required to introduce runtime extensibility mechanism in a user-space packet processing applications. It can be achieved by using <a href="https://github.com/iovisor/ubpf">the user-space BPF (uBPF) Virtual Machine</a>, which is a re-implementation of in-kernel eBPF VM and provides a user-space execution environment, which can be extended at runtime.</p> <p>This blog post introduces <strong>p4c-ubpf</strong> - the new back-end for the P4 compiler - that enables programming packet processing modules for uBPF. The p4c-ubpf allows to execute the P4 code in any solution implementing the kernel bypass (e.g. DPDK or AF_XDP applications).</p> <h1 id="userspace-bpf-for-packet-processing">Userspace BPF for packet processing</h1> <h2 id="why-ubpf">Why uBPF?</h2> <p>The uBPF project [1] re-implements the eBPF kernel-based Virtual Machine. It contains eBPF assembler, disassembler, interpreter, and JIT compiler for x86-64. While the BPF programs are intented to be run in the kernel, the uBPF project enables running the BPF programs in user-space applications. Therefore, the uBPF Virtual Machine can be well-integrated with the kernel bypass (e.g. DPDK/AF_XDP) applications.</p> <p>Moreover, contrary to the eBPF implementation, uBPF is not licensed under GPL. The uBPF implementation is licensed under Apache License, version 2.0. Finally, the userspace eBPF implements less complex virtual machine, so that some constructs are not supported (e.g. tail calls), but, on the other hand, the stack size of the uBPF program is not limited to 512 bytes.</p> <h2 id="p4rt-ovs">P4rt-OVS</h2> <p>Open vSwitch (OVS) is a widely adopted high-performance programmable virtual switch. P4rt-OVS is an extension of Open vSwitch that integrates the BPF virtual machine with the userspace datapath of OVS. Hence, P4rt-OVS allows to extend the OVS packet processing pipeline without recompilation by injecting BPF programs at runtime. BPF programs act as programmable actions and they are referenced as a new OVS action (keyword <code class="language-plaintext highlighter-rouge">prog</code>) in the OpenFlow tables. Programmable actions are allowed to write to packets as well as read and write to persistent maps (hash tables) to retain information on flows.</p> <p>Furthermore, a user can use the P4 language to develop new, protocol-independent data plane extensions (BPF programs) for Open vSwitch. P4 provides a high-level and declarative language, so writing a new network features becomes super easy! p4c-ubpf, the uBPF back-end for the P4 compiler, provides the architecture model to write P4 programs making use of wide range of P4 features including stateful registers.</p> <h1 id="compiling-p4-to-ubpf">Compiling P4 to uBPF</h1> <p>The P4-to-uBPF compiler follows the same convention as P4 compilers for eBPF or XDP backends, i.e. the P4 program is firstly translated to the C representation and, then, compiled to the BPF code using <code class="language-plaintext highlighter-rouge">clang</code> compiler. It makes things a little bit easier as P4 compiler does not need to generate low-level BPF instructions.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            ------------              ---------
P4_16 ---&gt;  | p4c-ubpf | ---&gt; C ----&gt; | clang | --&gt; uBPF
            ------------              ---------
</code></pre></div></div> <p>We designed a new architecture model for P4c-uBPF (depicted below). The <code class="language-plaintext highlighter-rouge">ubpf_model</code> architecture consists of a single parser, match-action pipeline, and deparser. We made the decision to disable packet forwarding in the first version, what simplifies the design, but can be treated as a limitation. It means it is the responsibility of the underlaying target to determine output port for incoming packets. P4rt-OVS is implemented according to this design principle. However, p4c-ubpf can be enhanced to support packet forwarding in the next releases.</p> <p><img src="/en/_posts/p4c-ubpf-architecture-model.png" alt="p4c-ubpf-architecture-model.png"/></p> <p>The p4c-ubpf compiler provides also a library of <em>extern</em> functions that implement features not supported by the P4 language. These functions can be called from the P4 program as a normal action. The <code class="language-plaintext highlighter-rouge">ubpf</code> architecture model supports such operations as hash functions, stateful registers, timestamp retrieving and checksum computation. To see the heavily commented, full specification of the architecture model see <a href="https://github.com/p4lang/p4c/blob/master/backends/ubpf/p4include/ubpf_model.p4">this link</a>.</p> <h2 id="translating-p4-to-c">Translating P4 to C</h2> <p>The key operation that is performed by p4c-ubpf is translation from P4 to C. The following tables provide a brief summary of how each P4 construct is mapped to a corresponding C construct. Note that the translation is very similar to <code class="language-plaintext highlighter-rouge">p4c-ebpf</code> and <code class="language-plaintext highlighter-rouge">p4c-xdp</code>.</p> <h4 id="translating-parser">Translating parser</h4> <table> <thead> <tr> <th>P4 Construct</th> <th>C Translation</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">header</code></td> <td><code class="language-plaintext highlighter-rouge">struct</code> type with an additional <code class="language-plaintext highlighter-rouge">valid</code> bit</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">struct</code></td> <td><code class="language-plaintext highlighter-rouge">struct</code></td> </tr> <tr> <td>parser state</td> <td>code block</td> </tr> <tr> <td>state transition</td> <td><code class="language-plaintext highlighter-rouge">goto</code> statement</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">extract</code></td> <td>load/shift/mask data from packet buffer</td> </tr> </tbody> </table> <h4 id="translating-match-action-pipelines">Translating match-action pipelines</h4> <table> <thead> <tr> <th>P4 Construct</th> <th>C Translation</th> </tr> </thead> <tbody> <tr> <td>table</td> <td>eBPF map</td> </tr> <tr> <td>table key</td> <td><code class="language-plaintext highlighter-rouge">struct</code> type</td> </tr> <tr> <td>table <code class="language-plaintext highlighter-rouge">actions</code> block</td> <td>tagged <code class="language-plaintext highlighter-rouge">union</code> with all possible actions</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">action</code> arguments</td> <td><code class="language-plaintext highlighter-rouge">struct</code></td> </tr> <tr> <td>table <code class="language-plaintext highlighter-rouge">reads</code></td> <td>eBPF map’s lookups</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">action</code> body</td> <td>code block</td> </tr> <tr> <td>table <code class="language-plaintext highlighter-rouge">apply</code></td> <td><code class="language-plaintext highlighter-rouge">switch</code> statement</td> </tr> <tr> <td>registers</td> <td>additional eBPF map</td> </tr> <tr> <td>register <code class="language-plaintext highlighter-rouge">reads</code></td> <td>eBPF map’s lookups</td> </tr> <tr> <td>register <code class="language-plaintext highlighter-rouge">writes</code></td> <td>eBPF map’s updates</td> </tr> </tbody> </table> <h4 id="translating-deparser">Translating deparser</h4> <table> <thead> <tr> <th>P4 Construct</th> <th>C Translation</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">apply</code> block</td> <td>code block + adjusting packet’s size</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">emit</code> operation</td> <td>header’s validity check + write/shift/mask data to packet buffer</td> </tr> </tbody> </table> <h1 id="p4c-ubpf-vs-other-bpf-related-compilers">p4c-ubpf vs. other BPF-related compilers</h1> <p>The uBPF is yet another BPF-related backend for P4. <code class="language-plaintext highlighter-rouge">p4c-ebpf</code> generates programs to be attached to the Linux TC subsystem, <code class="language-plaintext highlighter-rouge">p4c-xdp</code> targets XDP hook, while <code class="language-plaintext highlighter-rouge">p4c-ubpf</code> produces code to be run in at the user-space level. There are differences in the range of functionalities that these P4 backends support. The table below provides a brief comparison of features provided by each BPF-related backend.</p> <h4 id="comparsion-of-features-provided-by-p4c-ebpf-p4c-xdp-and-p4c-ubpf">Comparsion of features provided by p4c-ebpf, p4c-xdp and p4c-ubpf</h4> <table> <thead> <tr> <th style="text-align: center">Feature</th> <th style="text-align: center">p4c-ebpf</th> <th style="text-align: center">p4c-xdp</th> <th style="text-align: center">p4c-ubpf</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">Packet filtering</td> <td style="text-align: center">YES</td> <td style="text-align: center">YES</td> <td style="text-align: center">YES</td> </tr> <tr> <td style="text-align: center">Packet’s modifications &amp; tunneling</td> <td style="text-align: center">NO</td> <td style="text-align: center">YES</td> <td style="text-align: center">YES</td> </tr> <tr> <td style="text-align: center">Simple packet forwarding</td> <td style="text-align: center">YES</td> <td style="text-align: center">YES</td> <td style="text-align: center">NO</td> </tr> <tr> <td style="text-align: center">Registers</td> <td style="text-align: center">NO</td> <td style="text-align: center">NO</td> <td style="text-align: center">YES</td> </tr> <tr> <td style="text-align: center">Counters</td> <td style="text-align: center">YES</td> <td style="text-align: center">YES</td> <td style="text-align: center">NO</td> </tr> <tr> <td style="text-align: center">Checksum computation</td> <td style="text-align: center">NO</td> <td style="text-align: center">YES</td> <td style="text-align: center">YES</td> </tr> </tbody> </table> <h1 id="summary">Summary</h1> <p>The uBPF backend for the P4 compiler can be used for any application that processes packets in a user space. It has already been used to implement various, simple applications such as stateful firewall, rate limiter or GTP tunneling. For instance, in case of P4rt-OVS, <code class="language-plaintext highlighter-rouge">p4c-ubpf</code> allows to implement network protocols, which are not currently supported by Open vSwitch. See <a href="https://github.com/p4lang/p4c/tree/master/backends/ubpf/examples">this link</a> for more examples.</p> <p>We encourage community to start playing with uBPF backend, report bugs and propose new enhancements. For questions or comments, please send an email to tomasz.osinski2@orange.com.</p> <h1 id="quick-links">Quick links</h1> <p><a href="https://docs.cilium.io/en/v1.6/bpf/">BPF and XDP Reference Guide</a></p> <p><a href="https://github.com/p4lang/p4c/blob/master/backends/ebpf/README.md">Background on P4 and eBPF</a></p> <p><a href="https://www.openvswitch.org/support/ovscon2019/#4.3F">P4-uBPF - presentation from Open vSwitch and OVN Fall 2019 conference</a></p> <p><a href="https://github.com/Orange-OpenSource/p4rt-ovs">P4rt-OVS - Github repository</a></p>]]></content><author><name></name></author><category term="article"/><category term="P4"/><category term="uBPF"/><summary type="html"><![CDATA[NOTE: This blog post was originally published on P4.org: https://opennetworking.org/news-and-events/blog/p4c-ubpf-a-new-back-end-for-the-p4-compiler/.]]></summary></entry><entry><title type="html">My takeways from the “C Traps and Pitfalls” book</title><link href="https://osinstom.github.io/blog/2020/my-takeways-from-c-traps-and-pitfalls/" rel="alternate" type="text/html" title="My takeways from the “C Traps and Pitfalls” book"/><published>2020-02-05T00:00:00+00:00</published><updated>2020-02-05T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2020/my-takeways-from-c-traps-and-pitfalls</id><content type="html" xml:base="https://osinstom.github.io/blog/2020/my-takeways-from-c-traps-and-pitfalls/"><![CDATA[<p>Recently, I read the really nice book, entitled “C Traps and Pitfalls”, to extend my competences in C. This post gathers all my key findings and takeways from this book. I wrote this more for myself to note the key findings, but I think any C programmer can find something useful in my notes. Enjoy!</p> <h3 id="1-precendence-of-operators">1. Precendence of operators</h3> <p>Before going into the topic, quick reminder on what operators do we have in C:</p> <ul> <li><strong>Arithmetic operators</strong> - math operators such as <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>, <code class="language-plaintext highlighter-rouge">%</code></li> <li><strong>Increment and decrement operators</strong> - two operators (<code class="language-plaintext highlighter-rouge">++</code> and <code class="language-plaintext highlighter-rouge">--</code>) to change the value of an operand by one.</li> <li><strong>Assignment operators</strong> - for assigning the value to a variable: <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">+=</code>, <code class="language-plaintext highlighter-rouge">-=</code>, <code class="language-plaintext highlighter-rouge">*=</code>, <code class="language-plaintext highlighter-rouge">/=</code>, <code class="language-plaintext highlighter-rouge">%=</code>.</li> <li><strong>Relational operators</strong> - used in decision making or loops to check the relationship between two operands: <code class="language-plaintext highlighter-rouge">==</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">!=</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>.</li> <li><strong>Logical operators</strong> - to perform logical operations: <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> (AND), <code class="language-plaintext highlighter-rouge">||</code> (OR), <code class="language-plaintext highlighter-rouge">!</code> (NOT)</li> <li><strong>Bitwise operators</strong> - to perform operation on bits: <code class="language-plaintext highlighter-rouge">&amp;</code>, <code class="language-plaintext highlighter-rouge">|</code>, <code class="language-plaintext highlighter-rouge">^</code>, <code class="language-plaintext highlighter-rouge">~</code>, <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>.</li> </ul> <p>Except for above, there are two simple operators: sizeof and Comma operator.</p> <p>Now, where does the precendence of operators matter? In general, in any statement of the C program, but we would meet the most surprising traps in the <em>if</em> statements. According to the example from book, we could write the following statement to check if variable <code class="language-plaintext highlighter-rouge">flags</code> has some bit (represented as <code class="language-plaintext highlighter-rouge">FLAG</code>) turned on:</p> <pre><code class="language-C">if (flags &amp; FLAG != 0) ...
</code></pre> <p>Sic! The relational operator (<code class="language-plaintext highlighter-rouge">!=</code>) has the precendence over the bitwise operator (<code class="language-plaintext highlighter-rouge">&amp;</code>), so it totally changes our intention! The statement firstly compare <code class="language-plaintext highlighter-rouge">FLAG</code> with 0 and, then, takes the result of comparison and performs logical AND operation with flags. This was not our intention!</p> <p>In the book, there are more examples of such a traps in C. What we should remember is:</p> <blockquote> <p>The precendence of operators in C is as follows (from the highest precendence): The arithmetic operators, the shift operators, the relational operators, the logical operators, the assignment operators, the conditional operator.</p> </blockquote> <p>To conclude this paragraph, the operator’s precendence in C can make a lot of surprises for not experienced programmer.</p> <blockquote> <p>My hint? Use as much parenthesess as you need, but not more than really required, in the <em>if</em> statements to express your intention. You will avoid a lot of surprises this way.</p> </blockquote> <h3 id="2-mind-a-break-statement">2. Mind a break statement!</h3> <p>In the <em>switch</em> statement each <em>case</em> statement should be terminated with <em>break</em>. Otherwise, all the subsequent <em>case</em> statements will be also invoked until the first <em>break</em> ! Note that this trap may also be a nice feature of the language if used intentionally (e.g. in the compiler program to skip some tokens while analyzing the code).</p> <h3 id="3-dangling-else-problem">3. Dangling <em>else</em> problem</h3> <p>Consider the following example from the book:</p> <pre><code class="language-C">if (x == 0)
  if (y == 0) error();
else {
  z = x + y;
  f(&amp;z);
}
</code></pre> <p>The intention here is to enter <em>else</em> block if <code class="language-plaintext highlighter-rouge">x != 0</code>. However, in C, <em>else</em> is associated with the nearest <em>if</em> statement! Therefore, in the above example <em>else</em> statement will be invoked if <code class="language-plaintext highlighter-rouge">y != 0</code> (sic!).</p> <blockquote> <p>My hint? You should always use parenthesses in the <em>if-else</em> statements to make sure that C program behaves as you intended to.</p> </blockquote> <h3 id="4-order-of-evaluation">4. Order of evaluation</h3> <p>Order of evaluation for most operators in the C language is not defined. The compiler is free to evaluate such expressions in any order, if the compiler can guarantee a consistent results.</p> <p>The only the following operators specify and guarantee the particular order of evalation: sequential-evaluation (<code class="language-plaintext highlighter-rouge">,</code>), logical-AND (<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>), logical-OR (<code class="language-plaintext highlighter-rouge">||</code>) and conditional expression (<code class="language-plaintext highlighter-rouge">? :</code>).</p> <p>All other C operands evalute their operands in undefined order. It means their exact behavior is implementation-specific/</p> <h3 id="5-logical-vs-bitwise-comparison">5. Logical vs. bitwise comparison</h3> <p>Anyone should avoid using logical (e.g. <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>) and bitwise (<code class="language-plaintext highlighter-rouge">&amp;</code>) operators, interchangebly. For experienced programmers, it is obvious that these operators are not equivalent to each other. However, young programmers can substitute bitwise operator for logical operators or vice versa.</p> <p>In general the rule is simple:</p> <blockquote> <p>Logical operators treats their arguments as either “True” (value 1) or “False” (value 0). On the other hand, bitwise operators work on sequence of bits and compares bits of their arguments.</p> </blockquote> <p>According to the following example (from book):</p> <pre><code class="language-C">i = 0;
while (i &lt; tabsize &amp;&amp; tab[i] != x)
  i++;
</code></pre> <p>If the <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> would be replaced by <code class="language-plaintext highlighter-rouge">&amp;</code> we will have two consequences:</p> <ol> <li>In this example, both comparisons produce the value of 0 or 1, so that <code class="language-plaintext highlighter-rouge">&amp;</code> and <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> will work similarily. However, if one of the comparisons would produce some other value, the loop would work incorrectly.</li> <li>This is really tricky and can make a surprise! The <code class="language-plaintext highlighter-rouge">&amp;</code>, unlike <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, must <strong>always</strong> evaluate both of its operands. So, even if <code class="language-plaintext highlighter-rouge">i &lt; tabsize</code> is “False”, the second operand (<code class="language-plaintext highlighter-rouge">tab[i] != x</code>) will be evaluated! In this case, it leads to reading a value that is not in the bounds of the <code class="language-plaintext highlighter-rouge">tab</code> array.</li> </ol> <p>It is worth to remember these consequences as the recruiters like to ask this sort of questions at job interview :)</p> <h3 id="6-c-doesnt-cast-functions-arguments-automatically">6. C doesn’t cast function’s arguments automatically!</h3> <p>In other words:</p> <blockquote> <p>It is the programmer’s responsibility to ensure that the arguments toa function are of the right type.</p> </blockquote> <h3 id="7-allocate-enough-memory-for-strings">7. Allocate enough memory for strings</h3> <p>String is an array of characters, but this array is terminated with <code class="language-plaintext highlighter-rouge">'\0'</code> (null character). Therefore, we need allocate one extra character for string! For example, if <code class="language-plaintext highlighter-rouge">strlen(s)</code> equals <code class="language-plaintext highlighter-rouge">n</code>, <code class="language-plaintext highlighter-rouge">s</code> really requires <code class="language-plaintext highlighter-rouge">n+1</code> characters to be allocated.</p> <h3 id="8-integer-overflow">8. Integer overflow</h3> <blockquote> <p>If either operand is unsigned, the result is unsigned, and is defined to be modulo 2^n, where “n” is the word size. If both operands are signed, the result is <strong>undefined</strong>.</p> </blockquote> <h3 id="9-how-to-shift-bits">9. How to shift bits?</h3> <ol> <li> <p>It is more safe to right-shift <em>unsigned</em> integers. In some implementations, if the item is <em>signed</em>, it is allowed to fill vacatated bit positions either with zeros or with copies of the sign bit. The latter can make a surprise!</p> </li> <li> <p>It is not allowed to shift the variable by value greater than its length.</p> </li> </ol> <h3 id="10-what-c-preprocessor-gives-us">10. What C preprocessor gives us?</h3> <ol> <li>We can change all instances of a particular quantity by changing one number (in only one place) and recompiling the program. It is useful for some pre-defined variables like size of char arrays etc.</li> <li>We can define things to appear as functions, but without typical execution overhead, which applies to classical function calls. Preprocessor just replaces a function call inline with predefined operations defined in macros.</li> </ol> <h3 id="11-macros-are-not-functions">11. Macros are not functions</h3> <p>This statements is rather obvious for everyone, who has been working with C for some time now. However, it can be misunderstood by beginners.</p> <p>Even though macros usually looks like function calls, they are not the same! Come back to takeways #10 and remember: preprocessor replaces all macros instances with actual value of a macro. This may lead to surprises for less experienced programmers.</p> <p>In my personal opinion, macros should be used mindfully, because they are not always the best option. The macros imitating functions sometimes looks really ugly and far away from “clean code” principles. My hint?</p> <blockquote> <p>Use macros to imitate function only if a function is not complex. Otherwise, use typical functions to make a code more readable.</p> </blockquote> <h3 id="12-macros-are-not-typedefs">12. Macros are not typedefs</h3> <p>In C, there is a construct called <em>typedef</em>, which allows programmer to create new types. However, macros are also used to define new types. The rule to remember is that macros are not typedefs and can lead to a surprise. Consider below example (from book):</p> <pre><code class="language-C">// T1 and T2 conceptually seems to define the same type (pointer to a struct foo).
#define T1 struct foo *
typedef struct foo *T2;

// declarations
T1 a, b;
T2 c, d;
</code></pre> <p>Now, there is a surprise! Remember macros replaces its instances with the actual value. As a result we have:</p> <pre><code class="language-C">struct foo * a, b;
</code></pre> <p>So, “a” is a pointer to a struct foo, indeed. However, “b” is just a variable of type struct foo!</p> <h3 id="13-c-is-not-really-portable">13. C is not really portable</h3> <p>The chapter 7 of the book deals with portability pitfalls. To summarize this chapter it is really easy to say that C is not really portable language and every programmer needs to know, which platform she or he is programming on. A programmer has to know about underlaying platform’s features, libraries and limitations.</p> <p>What authors recommend to look at regarding portability?</p> <ul> <li>Case sensitivness - not all platforms/compilers are sensitive to case in names of variables/functions.</li> <li>Size of integers - the size is architecture-dependent. Usually we have 32 bit for integers, 16 bit for <em>short</em>, etc. However, it is not guaranteed.</li> <li>Converting char to int - it is not defined if a character should be transformed to unsigned or signed integer. If one wants to force conversion to unsigned integer it is better to declare <em>unsigned char</em>. In this case, extra bit positions should be filled with zeros. If casting from <em>char</em> it depends on implementation - a compiler may convert it to signed or unsigned integer.</li> <li>Random numbers - due to historical reasons, it is undefined what is an upper bound for randomly-generated number. However, it is granted to be at least 2^15-1.</li> </ul> <h2 id="summary">Summary</h2> <p>This book was a nice journey for me! As I spent a lot of time on programming C software during last year, it was not a revolutionary book for me. Nevertheless, it definetely expand my knowledge about C and I’m sure it provides a strong background and deep knowledge about specific constructs of C.</p>]]></content><author><name></name></author><category term="article"/><category term="C"/><category term="programming"/><summary type="html"><![CDATA[Recently, I read the really nice book, entitled “C Traps and Pitfalls”, to extend my competences in C. This post gathers all my key findings and takeways from this book. I wrote this more for myself to note the key findings, but I think any C programmer can find something useful in my notes. Enjoy!]]></summary></entry><entry><title type="html">OVS_AFXDP - step-by-step installation guide</title><link href="https://osinstom.github.io/blog/2020/ovs-afxdp-installation/" rel="alternate" type="text/html" title="OVS_AFXDP - step-by-step installation guide"/><published>2020-01-13T00:00:00+00:00</published><updated>2020-01-13T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2020/ovs-afxdp-installation</id><content type="html" xml:base="https://osinstom.github.io/blog/2020/ovs-afxdp-installation/"><![CDATA[<h2 id="introduction">Introduction</h2> <p><a href="http://docs.openvswitch.org/en/latest/intro/install/afxdp/">OVS_AFXDP</a> is a new datapath implementation for Open vSwitch. The new datapath is based on <a href="https://cilium.readthedocs.io/en/latest/bpf/">eXpress Data Path (XDP)</a> - the in-kernel hook for eBPF programs designed to provide high-performance packet processing subystem in Linux. AF_XDP is a new socket type (address family) that is built on top of XDP. AF_XDP redirects incoming packets to memory buffer in a user-space application.</p> <p>AF_XDP in Open vSwitch is expected to provide similar performance to the DPDK datapath, but with a lower configuration overhead. If AF_XDP will become a successful implementation it would allow to port existing kernel-based OVS deployments to the user-space implementations providing better packet processing performance.</p> <p>From my perspective, OVS_AFXDP is interesting as it can be the solution for P4rt-OVS (P4-capable Open vSwitch developed by my team at Orange Labs Poland), which requires to process packets in the user-space and is currently based on DPDK. Hence, I decided to test OVS_AFXDP and evaluate how it can be integrated to P4rt-OVS. This post describes the installation process that I went through. As there is only the official documentation on how to install OVS_AFXDP, this post can be a useful extension.</p> <h2 id="installation-of-ovs_afxdp">Installation of OVS_AFXDP</h2> <p>According to the official documentation, OVS_AFXDP requires at least kernel 5.0.0. I installed OVS_AFXDP on Ubuntu 18.10, which comes with kernel 4.18 already integrated. Kernel 4.18 has some initial support for XDP, but it is not suitable for OVS_AFXDP. Hence, we need to install the newer kernel first. I recommend you to install kernel 5.4.1 or higher because it introduces important modifications to how AF_XDP works.</p> <h3 id="building-kernel-with-the-xdp-support">Building kernel with the XDP support</h3> <p>I decided to install the latest stable version of Linux - 5.4.12:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt install -y build-essential libncurses-dev bison flex libssl-dev
wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.4.12.tar.xz
unxz -v linux-5.4.12.tar.xz
wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.4.12.tar.sign
gpg --verify linux-5.4.12.tar.sign
</code></pre></div></div> <p>The sample output will be:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gpg: assuming signed data in 'linux-5.4.12.tar'
gpg: Signature made Sun 12 Aug 2018 04:00:28 PM CDT
gpg:                using RSA key 647F28654894E3BD457199BE38DBBDC86092693E
gpg: Can't check signature: No public key
</code></pre></div></div> <p>Copy RSA to the clipboard and run:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gpg --recv-keys 647F28654894E3BD457199BE38DBBDC86092693E
gpg --verify linux-5.4.12.tar.sign
</code></pre></div></div> <p>Now, we can move to the installation process. Extract Linux package:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar xvf linux-5.4.12.tar
</code></pre></div></div> <p>Enter linux directory, make config and make sure that following options are enabled:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Open config editor and save it to .config</span>
<span class="nv">$ </span>make menuconfig
<span class="c"># or you can copy the current one:</span>
<span class="nv">$ </span><span class="nb">cp</span> <span class="nt">-v</span> /boot/config-<span class="si">$(</span><span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span> .config
<span class="c"># Check if following options are enabled:</span>
<span class="c"># CONFIG_BPF=y</span>
<span class="c"># CONFIG_BPF_SYSCALL=y</span>
<span class="c"># CONFIG_XDP_SOCKETS=y</span>
</code></pre></div></div> <p>Then, build the kernel:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-j</span> <span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span>
<span class="nb">sudo </span>make modules_install <span class="nv">INSTALL_MOD_STRIP</span><span class="o">=</span>1
<span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div> <p>The next, important step is to install kernel’s headers. They are used by userspace programs (such as Open vSwitch) to interface with kernel services. In other words, kernel’s headers provide the API for userspace programs. For instance, in case of OVS_AFXDP, <code class="language-plaintext highlighter-rouge">if_xdp.h</code> provides the API to the XDP socket.</p> <p><code class="language-plaintext highlighter-rouge">sudo make INSTALL_HDR_PATH=/usr headers_install</code></p> <p>After system’s reboot you should have up and running Linux 5.4.12 that will allow you to install OVS_AFXDP without any problems.</p> <h3 id="installing-ovs_afxdp">Installing OVS_AFXDP</h3> <p>Firstly, let’s install required tools and dependencies:</p> <p><code class="language-plaintext highlighter-rouge">sudo apt install -y git make gcc libelf-dev autoconf libtool</code></p> <p>Next, clone the OVS repository:</p> <p><code class="language-plaintext highlighter-rouge">git clone https://github.com/openvswitch/ovs</code></p> <p>Then, according to the official documentation, the <code class="language-plaintext highlighter-rouge">libbpf</code> should be installed:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone git://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git
<span class="nb">cd </span>bpf-next/
<span class="nb">cd </span>tools/lib/bpf/
make
<span class="nb">sudo </span>make <span class="nb">install
sudo </span>make install_headers
</code></pre></div></div> <p>In my case, above commands were not enough. I had to copy the <code class="language-plaintext highlighter-rouge">libbpf</code> shared library to location, where all libraries are stored and create a symbolic link. I based on the <a href="https://software.intel.com/en-us/articles/install-a-unix-including-linux-shared-library">tutorial from Intel</a>.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># from bpf-next/tools/lib/bpf/</span>
<span class="nb">sudo cp </span>libbpf.so.0 /usr/lib/
<span class="nb">sudo cp </span>libbpf.so.0.0.7 /usr/lib/
<span class="nb">sudo </span>ldconfig <span class="nt">-v</span> <span class="nt">-n</span> /usr/lib
<span class="nb">sudo ln</span> <span class="nt">-sf</span> /usr/lib/libbpf.so.0 /usr/lib/libbpf.so.0.0.7
<span class="nb">sudo </span>ldconfig
ldconfig <span class="nt">-p</span> | <span class="nb">grep </span>bpf
<span class="c"># You should have libbpf listed in the output of the above command.</span>
</code></pre></div></div> <p>Now, let’s configure OVS.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>ovs/
./boot.sh
./configure <span class="nt">--enable-afxdp</span>
</code></pre></div></div> <p>At this stage, if you use older kernel (e.g. 4.18 or even 5.0.0) you will get the following error during configuration process. This error will also appear if the command <code class="language-plaintext highlighter-rouge">sudo make INSTALL_HDR_PATH=/usr headers_install</code> has not been invoked.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>configure: WARNING: bpf/xsk.h: present but cannot be compiled
configure: WARNING: bpf/xsk.h:     check for missing prerequisite headers?
configure: WARNING: bpf/xsk.h: see the Autoconf documentation
configure: WARNING: bpf/xsk.h:     section "Present But Cannot Be Compiled"
configure: WARNING: bpf/xsk.h: proceeding with the compiler's result
configure: WARNING:     ## ----------------------------------- ##
configure: WARNING:     ## Report this to bugs@openvswitch.org ##
configure: WARNING:     ## ----------------------------------- ##
checking for bpf/xsk.h... no
configure: error: unable to find bpf/xsk.h for AF_XDP support
</code></pre></div></div> <p>If we would look at <code class="language-plaintext highlighter-rouge">config.log</code> we can see the following message:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>configure:18659: checking bpf/xsk.h usability
configure:18659: gcc -c -g -O2  conftest.c &gt;&amp;5
In file included from conftest.c:69:
/usr/local/include/bpf/xsk.h: In function 'xsk_ring_prod__needs_wakeup':
/usr/local/include/bpf/xsk.h:82:21: error: 'XDP_RING_NEED_WAKEUP' undeclared (first use in this function)
  return *r-&gt;flags &amp; XDP_RING_NEED_WAKEUP;
                     ^~~~~~~~~~~~~~~~~~~~
/usr/local/include/bpf/xsk.h:82:21: note: each undeclared identifier is reported only once for each function it appears in
/usr/local/include/bpf/xsk.h: In function 'xsk_umem__extract_addr':
/usr/local/include/bpf/xsk.h:173:16: error: 'XSK_UNALIGNED_BUF_ADDR_MASK' undeclared (first use in this function)
  return addr &amp; XSK_UNALIGNED_BUF_ADDR_MASK;
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/local/include/bpf/xsk.h: In function 'xsk_umem__extract_offset':
/usr/local/include/bpf/xsk.h:178:17: error: 'XSK_UNALIGNED_BUF_OFFSET_SHIFT' undeclared (first use in this function)
  return addr &gt;&gt; XSK_UNALIGNED_BUF_OFFSET_SHIFT;
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre></div></div> <p>This is caused by the old version of <code class="language-plaintext highlighter-rouge">if_xdp.h</code> that does not provide declaration of <code class="language-plaintext highlighter-rouge">XDP_RING_NEED_WAKEUP</code> and others. <em>If you get this error, come back to the section <code class="language-plaintext highlighter-rouge">Building kernel with the XDP support</code> and install kernel 5.4.12, which comes with <code class="language-plaintext highlighter-rouge">if_xdp.h</code> supporting those declarations.</em></p> <p>If <code class="language-plaintext highlighter-rouge">./configure</code> has been completed successfully, let’s build OVS_AFXDP:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make -j $(nproc)
sudo make install
</code></pre></div></div> <p>Voila! OVS_AFXDP is ready to be run!</p> <h3 id="running-ovs_afxdp">Running OVS_AFXDP</h3> <p>It is recommended to run tests first to check basic AF_XDP functionality:</p> <p><code class="language-plaintext highlighter-rouge">make check-afxdp TESTSUITEFLAGS='1'</code></p> <p><strong>Note!</strong> If <code class="language-plaintext highlighter-rouge">libbpf</code> has not been installed properly the test will fail with the following message:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>020-01-17 06:54:19.418142218 +0000
@@ -0,0 +1 @@
+ovsdb-tool: error while loading shared libraries: libbpf.so.0: cannot open shared object file: No such file or directory
./system-afxdp.at:5: exit code was 127, expected 0
</code></pre></div></div> <p>In my case I had to fix the installation of <code class="language-plaintext highlighter-rouge">libbpf</code>.</p> <p>If tests were passed, we can move on and run OVS_AFXDP! Firstly, let’s run OVSDB and <code class="language-plaintext highlighter-rouge">ovs-vswitchd</code>.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo mkdir -p /usr/local/etc/openvswitch
sudo ovsdb-tool create /usr/local/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema
sudo mkdir -p /usr/local/var/run/openvswitch
sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \
    --remote=db:Open_vSwitch,Open_vSwitch,manager_options \
    --pidfile --detach
sudo ovs-vswitchd --pidfile --detach    
</code></pre></div></div> <p>Then, let’s configure OVS with the <em>netdev</em> datapath:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl -- add-br br0 -- set Bridge br0 datapath_type=netdev
</code></pre></div></div> <p>OVS_AFXDP can be configured with both physical and virutal interfaces. For the test purpose, I use <code class="language-plaintext highlighter-rouge">veth</code> interfaces.</p> <p>Create two <code class="language-plaintext highlighter-rouge">veth</code> pairs and attach them to OVS:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ip netns add test0
sudo ip link add port0 type veth peer name peer0
sudo ip link set port0 netns test0
sudo ip link set dev peer0 up
sudo ovs-vsctl add-port br0 peer0 -- set interface peer0 external-ids:iface-id="port0" type="afxdp"

sudo ip netns exec test0 sh &lt;&lt; NS_EXEC_HEREDOC
ip addr add "10.1.1.1/24" dev port0
ip link set dev port0 up
NS_EXEC_HEREDOC

sudo ip netns add test1
sudo ip link add port1 type veth peer name peer1
sudo ip link set port1 netns test1
sudo ip link set dev peer1 up
sudo ovs-vsctl add-port br0 peer1 -- set interface peer1 external-ids:iface-id="port1" type="afxdp"

sudo ip netns exec test1 sh &lt;&lt; NS_EXEC_HEREDOC
ip addr add "10.1.1.2/24" dev port1
ip link set dev port1 up
NS_EXEC_HEREDOC
</code></pre></div></div> <p>The final configuration of OVS should looks as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@ovsafxdp:~/ovs$ sudo ovs-vsctl show
e7c40460-0252-4c98-a225-44416c01ead2
    Bridge br0
        datapath_type: netdev
        Port peer1
            Interface peer1
                type: afxdp
        Port br0
            Interface br0
                type: internal
        Port peer0
            Interface peer0
                type: afxdp
</code></pre></div></div> <p>To test if OVS_AFXDP works, let’s run <code class="language-plaintext highlighter-rouge">ping</code> in both directions:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ubuntu@ovsafxdp:~/ovs$ sudo ip netns exec test0 ping 10.1.1.2
PING 10.1.1.2 (10.1.1.2) 56(84) bytes of data.
64 bytes from 10.1.1.2: icmp_seq=1 ttl=64 time=0.179 ms
64 bytes from 10.1.1.2: icmp_seq=2 ttl=64 time=0.110 ms
64 bytes from 10.1.1.2: icmp_seq=3 ttl=64 time=0.106 ms

ubuntu@ovsafxdp:~/ovs$ sudo ip netns exec test1 ping 10.1.1.1
PING 10.1.1.1 (10.1.1.1) 56(84) bytes of data.
64 bytes from 10.1.1.1: icmp_seq=1 ttl=64 time=0.820 ms
64 bytes from 10.1.1.1: icmp_seq=2 ttl=64 time=0.104 ms
64 bytes from 10.1.1.1: icmp_seq=3 ttl=64 time=0.086 ms
</code></pre></div></div> <h2 id="summary">Summary</h2> <p>In this post, I described the installation and configuration process to make OVS_AFXDP up and running. As I encountered some problems on the way to install OVS_AFXDP I thought that it was worth sharing my experience with the community. Hence, this post can be a useful complement to the official documentation of OVS_AFXDP. Enjoy!</p> <p>The next step is to run our P4rt-OVS prototype with AF_XDP and get rid of DPDK. We also consider to integrate OVS_AFXDP with Mininet to provide researchers and network engineers a simple tool to run and test P4rt-OVS, without the need for DPDK.</p>]]></content><author><name></name></author><category term="tutorial"/><category term="OVS"/><category term="AF_XDP"/><category term="XDP"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Implementing tunneling techniques in P4 based on the example of VXLAN</title><link href="https://osinstom.github.io/blog/2019/vxlan-tunneling-in-p4/" rel="alternate" type="text/html" title="Implementing tunneling techniques in P4 based on the example of VXLAN"/><published>2019-08-07T00:00:00+00:00</published><updated>2019-08-07T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2019/vxlan-tunneling-in-p4</id><content type="html" xml:base="https://osinstom.github.io/blog/2019/vxlan-tunneling-in-p4/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>Recently, I started to implement the support for packet tunneling in our <a href="https://github.com/P4-Research/p4c/tree/master/backends/ubpf">P4C-to-uBPF</a> compiler. However, in order to deeply understand P4 constructs describing tunneling I have created the reference implementation of the VXLAN tunneling for BMv2 switch.</p> <p>This blog post describes how to design and implement more complex tunneling technique (like VXLAN) in the P4 language. The source code is available on <a href="https://github.com/P4-Research/p4-demos/tree/master/vxlan">Github</a>.</p> <h2 id="short-introduction-to-vxlan">Short introduction to VXLAN</h2> <p>The VXLAN (Virtual eXtensible Local Area Network) protocol has been standardized in <a href="https://tools.ietf.org/html/rfc7348">RFC 7348</a> and is usually used to provide overlay communications between virtual machines in the multi-tenant virtualized data center. It isolates logically networks by using Virtual Network Identifier (VNI). The VNI uniquely identifies a Network Segment or, interchangeably, VXLAN Overlay Network. For more information on how VXLAN works visit these references:</p> <p><a href="https://sites.google.com/site/amitsciscozone/home/data-center/vxlan">https://sites.google.com/site/amitsciscozone/home/data-center/vxlan</a></p> <p><a href="https://medium.com/@NTTICT/vxlan-explained-930cc825a51">https://medium.com/@NTTICT/vxlan-explained-930cc825a51</a></p> <p><a href="https://tools.ietf.org/html/rfc7348">RFC 7348</a></p> <h2 id="design-and-implementation-of-vxlan-in-p4">Design and implementation of VXLAN in P4</h2> <p>In this section I describe more interesting parts of the P4 program. The P4 source code is divided into <a href="https://github.com/P4-Research/p4-demos/blob/master/vxlan/vxlan.p4app/header.p4">header.p4</a>, <a href="https://github.com/P4-Research/p4-demos/blob/master/vxlan/vxlan.p4app/parser.p4">parser.p4</a> and <a href="https://github.com/P4-Research/p4-demos/blob/master/vxlan/vxlan.p4app/vxlan.p4">vxlan.p4</a>.</p> <h3 id="headers">Headers</h3> <p>This P4 program will use four types of headers: Ethernet, IP, UDP and VXLAN. The VXLAN header is defined as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>header vxlan_t {
    bit&lt;8&gt;  flags;
    bit&lt;24&gt; reserved;
    bit&lt;24&gt; vni;
    bit&lt;8&gt;  reserved_2;
}
</code></pre></div></div> <p>In fact, in this example only VNI will be used, the rest of fields will be set to zero.</p> <h3 id="parser">Parser</h3> <p>When implementing VXLAN tunneling we need to have more complex parsing logic in order to parse properly packets that arrive encapsulated into VXLAN header. For such packets the parser need to handle outer Ethernet, IP, UDP and VXLAN headers and the inner Ethernet and IP headers. Therefore, the implementation looks as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define UDP_PORT_VXLAN 4789
#define UDP_PROTO 17
#define IPV4_ETHTYPE 0x800

parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
    state start {
        transition parse_ethernet;
    }
    state parse_ethernet {
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
            IPV4_ETHTYPE: parse_ipv4;
            default: accept;
        }
    }
    state parse_ipv4 {
        packet.extract(hdr.ipv4);
        transition select(hdr.ipv4.protocol) {
            UDP_PROTO: parse_udp;
            default: accept;
        }
    }
    state parse_udp {
        packet.extract(hdr.udp);
        transition select(hdr.udp.dstPort) {
            UDP_PORT_VXLAN: parse_vxlan;
            default: accept;
         }
    }
    state parse_vxlan {
        packet.extract(hdr.vxlan);
        transition parse_inner_ethernet;
    }
    state parse_inner_ethernet {
        packet.extract(hdr.inner_ethernet);
        transition select(hdr.ethernet.etherType) {
            IPV4_ETHTYPE: parse_inner_ipv4;
            default: accept;
        }
    }
    state parse_inner_ipv4 {
        packet.extract(hdr.inner_ipv4);
        transition accept;
    }
}

control DeparserImpl(packet_out packet, in headers hdr) {
    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
        packet.emit(hdr.udp);
        packet.emit(hdr.vxlan);
        packet.emit(hdr.inner_ethernet);
        packet.emit(hdr.inner_ipv4);
    }
}

control verifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}

control computeChecksum(inout headers hdr, inout metadata meta) {
    apply {

    }
}

</code></pre></div></div> <p>The parser distinguish if the packet is encapsulated in VXLAN based on the UDP destination port, which should be set to 4789, which is the standard port for VXLAN encapsulation. Then if the packet is encapsulated parser goes through following stages: parse_vxlan() -&gt; parse_inner_ethernet() -&gt; parse_inner_ipv4().</p> <p>In the same file I have implemented deparser, which defines the order, in which headers are written to packets at the egress.</p> <h3 id="control-blocks">Control blocks</h3> <p>It is a good practice to design P4 programs (especially those that perform tunneling) by dividing the P4 program into four functional blocks:</p> <ul> <li><strong><em>Upstream ingress</em></strong> - ingress control block for incoming <em><strong>encapsulated</strong></em> packets.</li> <li><em><strong>Upstream egress</strong></em> - egress control block for outgoing packets, that arrived as encapsulated.</li> <li><em><strong>Downstream ingress</strong></em> - control block for incoming raw (not encapsulated) packets.</li> <li><strong><em>Downstream egress</em></strong> - control block for outgoing packets, that arrived as not encapsulated.</li> </ul> <p>Upstream and downstreams terms refer to the direction of the traffic. The upstream traffic is the traffic that is encapsulated (traffic being sent between VXLAN endpoints) and should be decapsulated at the ingress. On the contrary, the downstream traffic is the traffic, which is not encapsulated yet (traffic from host to switch). It simplify thinking of the P4 program design.</p> <h4 id="upstream-ingress">Upstream ingress</h4> <p>The upstream ingress needs to validate the VXLAN header and strip it out. Moreover, it must perform L2 forwarding to send the decapsulated packet.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>control vxlan_ingress_upstream(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

    action vxlan_decap() {
        // as simple as set outer headers as invalid
        hdr.ethernet.setInvalid();
        hdr.ipv4.setInvalid();
        hdr.udp.setInvalid();
        hdr.vxlan.setInvalid();
    }

    table t_vxlan_term {
        key = {
            // Inner Ethernet desintation MAC address of target VM
            hdr.inner_ethernet.dstAddr : exact;
        }

        actions = {
            @defaultonly NoAction;
            vxlan_decap();
        }

    }

    action forward(bit&lt;9&gt; port) {
        standard_metadata.egress_spec = port;
    }

    table t_forward_l2 {
        key = {
            hdr.inner_ethernet.dstAddr : exact;
        }

        actions = {
            forward;
        }
    }

    apply {
        if (hdr.ipv4.isValid()) {
            if (t_vxlan_term.apply().hit) {
                t_forward_l2.apply();
            }
        }
    }
}
</code></pre></div></div> <p>It is implemented in the vxlan_ingress_upstream control block using two tables: t_vxlan_term and t_forward_l2. The former decapsulates packets that matches the key. The destination MAC address of the inner Ethernet header should point to the host that is directly connected to VXLAN endpoint (the switch) via Layer 2 network. Encapsulation action sets outer headers as invalid, so that the deparser knows not to put these headers in the output packet. If the t_vxlan_term is hit, the t_forward_l2 is responsible for forwarding packet based on the destination MAC address of the inner Ethernet header.</p> <h4 id="upstream-egress">Upstream egress</h4> <p>In the context of VXLAN processing the upstream egress block does not need to do anything.</p> <h4 id="downstream-ingress">Downstream ingress</h4> <p>The downstream ingress is responsible for determining the value of the VNI identifier that will be used to encapsulate L2 packet by the downstream egress. Moreover, it determines source IP address and next hop IP address for the encapsulated packets. It also performs routing for encapsulates packets.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>control vxlan_ingress_downstream(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

    action set_vni(bit&lt;24&gt; vni) {
        meta.vxlan_vni = vni;
    }

    action set_ipv4_nexthop(bit&lt;32&gt; nexthop) {
        meta.nexthop = nexthop;
    }

    table t_vxlan_segment {

        key = {
            hdr.ipv4.dstAddr : lpm;
        }

        actions = {
            @defaultonly NoAction;
            set_vni;
        }

    }

    table t_vxlan_nexthop {

        key = {
            hdr.ethernet.dstAddr : exact;
        }

        actions = {
            set_ipv4_nexthop;
        }
    }

    action set_vtep_ip(bit&lt;32&gt; vtep_ip) {
        meta.vtepIP = vtep_ip;
    }

    table t_vtep {
        key = {
            hdr.ethernet.srcAddr : exact;
        }

        actions = {
            set_vtep_ip;
        }

    }

    action route(bit&lt;9&gt; port) {
        standard_metadata.egress_spec = port;
    }

    table t_vxlan_routing {

        key = {
            meta.nexthop : exact;
        }

        actions = {
            route;
        }
    }

    apply {
        if (hdr.ipv4.isValid()) {
            t_vtep.apply();
            if(t_vxlan_segment.apply().hit) {
                if(t_vxlan_nexthop.apply().hit) {
                    t_vxlan_routing.apply();
                }
            }
        }
    }

}
</code></pre></div></div> <p>The apply method firsty invokes t_vtep table, which determines source IP address for encapsulated packets based on source MAC address. The source MAC address is the address of the host that is directly connected to the VXLAN endpoint (switch). Then, the control block determines VXLAN Segment ID (the value of VNI) based on the IP subnet mask. Each IP subnet gets unique VNI. If the VXLAN Segment ID is found the next hop IP address is determined. It would be the IP address of the peer VXLAN endpoint. Finally, the P4 enforce to determine output port for packet at the ingress pipeline. Thus, t_vxlan_routing table determines output port based on the next hop IP address. At this moment, everything is prepared to encapsulate packet and send it out in the downstream egress block.</p> <h4 id="downstream-egress">Downstream egress</h4> <p>If the VNI has been determined in the ingress downstream block the downstream egress block just encapsulates the packet and sends the L2 frame.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>control vxlan_egress_downstream(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {

    action rewrite_macs(bit&lt;48&gt; smac, bit&lt;48&gt; dmac) {
        hdr.ethernet.srcAddr = smac;
        hdr.ethernet.dstAddr = dmac;
    }

    table t_send_frame {

            key = {
                hdr.ipv4.dstAddr : exact;
            }

            actions = {
                rewrite_macs;
            }
        }

    action vxlan_encap() {

        hdr.inner_ethernet = hdr.ethernet;
        hdr.inner_ipv4 = hdr.ipv4;

        hdr.ethernet.setValid();

        hdr.ipv4.setValid();
        hdr.ipv4.version = IP_VERSION_4;
        hdr.ipv4.ihl = IPV4_MIN_IHL;
        hdr.ipv4.diffserv = 0;
        hdr.ipv4.totalLen = hdr.ipv4.totalLen
                            + (ETH_HDR_SIZE + IPV4_HDR_SIZE + UDP_HDR_SIZE + VXLAN_HDR_SIZE);
        hdr.ipv4.identification = 0x1513; /* From NGIC */
        hdr.ipv4.flags = 0;
        hdr.ipv4.fragOffset = 0;
        hdr.ipv4.ttl = 64;
        hdr.ipv4.protocol = UDP_PROTO;
        hdr.ipv4.dstAddr = meta.nexthop;
        hdr.ipv4.srcAddr = meta.vtepIP;
        hdr.ipv4.hdrChecksum = 0;

        hdr.udp.setValid();
        // The VTEP calculates the source port by performing the hash of the inner Ethernet frame's header.
        hash(hdr.udp.srcPort, HashAlgorithm.crc16, (bit&lt;13&gt;)0, { hdr.inner_ethernet }, (bit&lt;32&gt;)65536);
        hdr.udp.dstPort = UDP_PORT_VXLAN;
        hdr.udp.length = hdr.ipv4.totalLen + (UDP_HDR_SIZE + VXLAN_HDR_SIZE);
        hdr.udp.checksum = 0;

        hdr.vxlan.setValid();
        hdr.vxlan.reserved = 0;
        hdr.vxlan.reserved_2 = 0;
        hdr.vxlan.flags = 0;
        hdr.vxlan.vni = meta.vxlan_vni;

    }

    apply {
        if (meta.vxlan_vni != 0) {
            vxlan_encap();
            if (hdr.vxlan.isValid()) {
                t_send_frame.apply();
            }
        }
    }

}
</code></pre></div></div> <p>However, the vxlan_encap() action is quite complex. Firsty, it copies the contenct of Ethernet and IP headers to the inner Ethernet and IP headers so it will act as a packet payload now. Then, outer headers (Ethernet, IP, UDP and VXLAN) are set valid and their header’s fields are filled. For the outer IP header the destination IP address is taken from nexthop value, which is stored in metadata. Similarily, the source IP address is set to the IP address of the VXLAN endpoint. Furthermore, the UDP header is pushed. Note that the source UDP port is caluclated as a hash value of Ethernet header (according to specification).</p> <p>Once the packet is encapsulated the MAC addresses of outer Ethernet header are set accordingly to the configuration of the switch interfaces.</p> <h2 id="running-example">Running example</h2> <p>In order to run example I have used <a href="https://github.com/p4lang/p4app/">p4app</a>, which is really nice and simple tool (based on Docker and Mininet) to test P4 programs. I have heard about p4app during the last <a href="https://netsoft2019.ieee-netsoft.org/">IEEE NetSoft conference</a>, good to be there!</p> <p>We will use simple Mininet topology with two switches and two hosts. The test environment is described in <a href="https://github.com/P4-Research/p4-demos/blob/master/vxlan/vxlan.p4app/p4app.json">the p4app manifest file</a>. I had to write simple controller module to avoid setting up L3 configuration for hosts. I have also configured Mininet with staticArp(), so that I didn’t have to implement <a href="https://blogs.vmware.com/vsphere/2013/05/vxlan-series-how-vtep-learns-and-creates-forwarding-table-part-5.html">ARP handling mechanism for VXLAN endpoints</a>. It requires more complex P4 logic and for the sake of simplicity I have omitted this part of VTEP’s functionality in the P4 program.</p> <p>Run the demo:</p> <p><code class="language-plaintext highlighter-rouge">sudo p4app run vxlan.p4app</code></p> <p>It will start Mininet, install the VXLAN P4 program on the switches and configure flow rules for them.</p> <p>You can test VXLAN encapsulation by sending some traffic (e.g. ping). By running <em>tcpdump</em> on the switch interfaces gives you insight on how packets are handled:</p> <p>s1-eth1</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11:14:54.689967 00:04:00:00:01:01 <span class="o">(</span>oui Unknown<span class="o">)</span> <span class="o">&gt;</span> 00:04:00:00:02:01 <span class="o">(</span>oui Unknown<span class="o">)</span>, ethertype IPv4 <span class="o">(</span>0x0800<span class="o">)</span>, length 98: 10.0.0.1 <span class="o">&gt;</span> 10.0.0.2: ICMP <span class="nb">echo </span>request, <span class="nb">id </span>113, <span class="nb">seq </span>23, length 64

11:14:54.692320 00:04:00:00:02:01 <span class="o">(</span>oui Unknown<span class="o">)</span> <span class="o">&gt;</span> 00:04:00:00:01:01 <span class="o">(</span>oui Unknown<span class="o">)</span>, ethertype IPv4 <span class="o">(</span>0x0800<span class="o">)</span>, length 98: 10.0.0.2 <span class="o">&gt;</span> 10.0.0.1: ICMP <span class="nb">echo </span>reply, <span class="nb">id </span>113, <span class="nb">seq </span>23, length 64
</code></pre></div></div> <p>s1-eth2</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11:15:14.719712 00:aa:00:01:00:02 <span class="o">(</span>oui Unknown<span class="o">)</span> <span class="o">&gt;</span> 00:aa:00:02:00:03 <span class="o">(</span>oui Unknown<span class="o">)</span>, ethertype IPv4 <span class="o">(</span>0x0800<span class="o">)</span>, length 148: 192.168.11.1.58032 <span class="o">&gt;</span> 192.168.11.254.4789: VXLAN, flags <span class="o">[</span>.] <span class="o">(</span>0x00<span class="o">)</span>, vni 22
00:04:00:00:01:01 <span class="o">(</span>oui Unknown<span class="o">)</span> <span class="o">&gt;</span> 00:04:00:00:02:01 <span class="o">(</span>oui Unknown<span class="o">)</span>, ethertype IPv4 <span class="o">(</span>0x0800<span class="o">)</span>, length 98: 10.0.0.1 <span class="o">&gt;</span> 10.0.0.2: ICMP <span class="nb">echo </span>request, <span class="nb">id </span>113, <span class="nb">seq </span>43, length 64

11:15:14.720664 00:aa:00:02:00:03 <span class="o">(</span>oui Unknown<span class="o">)</span> <span class="o">&gt;</span> 00:aa:00:01:00:02 <span class="o">(</span>oui Unknown<span class="o">)</span>, ethertype IPv4 <span class="o">(</span>0x0800<span class="o">)</span>, length 148: 192.168.11.254.43328 <span class="o">&gt;</span> 192.168.11.1.4789: VXLAN, flags <span class="o">[</span>.] <span class="o">(</span>0x00<span class="o">)</span>, vni 22
00:04:00:00:02:01 <span class="o">(</span>oui Unknown<span class="o">)</span> <span class="o">&gt;</span> 00:04:00:00:01:01 <span class="o">(</span>oui Unknown<span class="o">)</span>, ethertype IPv4 <span class="o">(</span>0x0800<span class="o">)</span>, length 98: 10.0.0.2 <span class="o">&gt;</span> 10.0.0.1: ICMP <span class="nb">echo </span>reply, <span class="nb">id </span>113, <span class="nb">seq </span>43, length 64
</code></pre></div></div> <p>s2-eth2</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11:15:14.719712 00:aa:00:01:00:02 (oui Unknown) &gt; 00:aa:00:02:00:03 (oui Unknown), ethertype IPv4 (0x0800), length 148: 192.168.11.1.58032 &gt; 192.168.11.254.4789: VXLAN, flags [.] (0x00), vni 22
00:04:00:00:01:01 (oui Unknown) &gt; 00:04:00:00:02:01 (oui Unknown), ethertype IPv4 (0x0800), length 98: 10.0.0.1 &gt; 10.0.0.2: ICMP echo request, id 113, seq 82, length 64

11:15:14.720664 00:aa:00:02:00:03 (oui Unknown) &gt; 00:aa:00:01:00:02 (oui Unknown), ethertype IPv4 (0x0800), length 148: 192.168.11.254.43328 &gt; 192.168.11.1.4789: VXLAN, flags [.] (0x00), vni 22
00:04:00:00:02:01 (oui Unknown) &gt; 00:04:00:00:01:01 (oui Unknown), ethertype IPv4 (0x0800), length 98: 10.0.0.2 &gt; 10.0.0.1: ICMP echo reply, id 113, seq 82, length 64
</code></pre></div></div> <p>s2-eth1</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11:15:14.719712 00:04:00:00:01:01 (oui Unknown) &gt; 00:04:00:00:02:01 (oui Unknown), ethertype IPv4 (0x0800), length 98: 10.0.0.1 &gt; 10.0.0.2: ICMP echo request, id 113, seq 133, length 64

11:15:14.720664 00:04:00:00:02:01 (oui Unknown) &gt; 00:04:00:00:01:01 (oui Unknown), ethertype IPv4 (0x0800), length 98: 10.0.0.2 &gt; 10.0.0.1: ICMP echo reply, id 113, seq 133, length 64
</code></pre></div></div> <h2 id="summary">Summary</h2> <p>The P4 implementation of the more advanced tunneling techniques (like VXLAN) requires a bit more effort than more standard networking. The purpose of this tutorial was to show how to implement them properly in the P4 language. I really recommend to split control block into four parts implementing upstream ingress and egress and downstream ingress and egress, seperately. It is <em>the good practice</em> that should ease the programming of the complex P4 programs. Following the VXLAN example one can implement similar tunneling techniques such as GPRS Tunneling Protocol (GTP) or Network Virtualization using Generic Routing Encapsulation (NVGRE).</p>]]></content><author><name></name></author><category term="tutorial"/><category term="p4app"/><category term="tunneling"/><category term="SDN"/><category term="P4"/><category term="VXLAN"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Configuring OVS-DPDK with VM</title><link href="https://osinstom.github.io/blog/2019/configuring-ovs-dpdk-with-vm/" rel="alternate" type="text/html" title="Configuring OVS-DPDK with VM"/><published>2019-03-23T00:00:00+00:00</published><updated>2019-03-23T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2019/configuring-ovs-dpdk-with-vm</id><content type="html" xml:base="https://osinstom.github.io/blog/2019/configuring-ovs-dpdk-with-vm/"><![CDATA[<h2 id="configuring-ovs-dpdk-with-vm-for-performance-testing">Configuring OVS-DPDK with VM for performance testing</h2> <p>Recently, I work on a performance comparison between virtualization technologies. In order to made an experiment I had had to setup a test environment based on <a href="https://software.intel.com/en-us/articles/open-vswitch-with-dpdk-overview">OVS-DPDK</a> and <a href="https://www.redhat.com/en/topics/virtualization/what-is-KVM">KVM-based Virtual Machine</a>. This user guide shows how to install and configure the test scenario with OVS-DPDK and libvirt. The test scenario is presented below. According to OVS flow rules configuration we can test PHY-OVS-PHY scenario (green line) or PHY-VM-PHY scenario (red line).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/OVS-DPDK-VM/test-scenario-ovs-dpdk-480.webp 480w,/assets/img/OVS-DPDK-VM/test-scenario-ovs-dpdk-800.webp 800w,/assets/img/OVS-DPDK-VM/test-scenario-ovs-dpdk-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/OVS-DPDK-VM/test-scenario-ovs-dpdk.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The OVS-DPDK + VM scenario </div> <h3 id="prerequisites">Prerequisites</h3> <p>Before starting installation of OVS-DPDK and VMs, let’s prepare OS.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get update
sudo apt-get upgrade

sudo apt-get -y install git qemu-system-x86 python-pip fuse libfuse-dev dh-autoreconf openssl libssl-dev cmake libpcap-dev python-yaml libnuma-dev
</code></pre></div></div> <h3 id="installing-ovs-dpdk">Installing OVS-DPDK</h3> <p>Firstly, we need to install DPDK and Open vSwitch from a source code. To install DPDK run below commands:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd $HOME &amp; mkdir dpdk
cd dpdk/
wget http://fast.dpdk.org/rel/dpdk-18.11.tar.xz
tar xf dpdk-18.11.tar.xz
cd dpdk-18.11/
</code></pre></div></div> <p>Then, we need to export environment variables, which point out to DPDK..</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export DPDK_DIR=$HOME/dpdk/dpdk-18.11
export DPDK_TARGET=x86_64-native-linuxapp-gcc
export DPDK_BUILD=$DPDK_DIR/$DPDK_TARGET
</code></pre></div></div> <p>.. and install DPDK. Note that we are using special flags (<em>-g -Ofast -march=native -Q</em>) to achieve a better performance of OVS-DPDK.</p> <p><code class="language-plaintext highlighter-rouge">EXTRA_CFLAGS="-g -Ofast" make install -j T=$target CONFIG_RTE_BUILD_COMBINE_LIBS=y CONFIG_RTE_LIBRTE_VHOST=y DESTDIR=install</code></p> <p>If the installation of DPDK has been successful, you can install OVS-DPDK.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd $HOME/dpdk/
git clone https://github.com/openvswitch/ovs
cd ovs
./boot.sh
./configure CFLAGS="-g -Ofast" --with-dpdk=$DPDK_BUILD
make -j CFLAGS="-g -Ofast -march=native -Q"
sudo make install
</code></pre></div></div> <p>Now, you should be able to verify OVS-DPDK installation by using below commands:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tomek@s14-2:~$ sudo ovs-vsctl show
3bb620bf-4d6f-4ddc-94ff-03f1ff9ccc93
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tomek@s14-2:~$ sudo ovs-vswitchd --version
ovs-vswitchd (Open vSwitch) 2.11.90
DPDK 18.11.0
</code></pre></div></div> <h3 id="configuring-ovs-dpdk">Configuring OVS-DPDK</h3> <p>Firstly, let’s configure DPDK ports. Following commands inject required kernel driver (i.e. uio, igb_uio, vfio). It is up to you, which one you would like to use. In order to choose one refer to https://doc.dpdk.org/guides/linux_gsg/linux_drivers.html. For our purposes we have used <em>uiopcigeneric</em>.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd dpdk/dpdk-18.11/usertools/
sudo modprobe uio_pci_generic
</code></pre></div></div> <p>Once kernel module has been injected NICs can be attached to DPDK. Note that you need to use the <em>bus-info</em> format (e.g.0000:88:00.0). To retrieve NIC ID in the bus-info format use:</p> <p><code class="language-plaintext highlighter-rouge">lspci | grep Ethernet</code></p> <p>This command will list all interfaces along with the bus-info identifier. Then, use dpdk-devbind.py script to bind chosen interfaces with DPDK drivers.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> ./dpdk-devbind.py <span class="nt">-b</span> uio_pci_generic 0000:88:00.0
<span class="nb">sudo</span> ./dpdk-devbind.py <span class="nt">-b</span> uio_pci_generic 0000:88:00.1
</code></pre></div></div> <p>You can check if interfaces have been bound successfully using:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tomek@s14-2:~/dpdk/dpdk-18.11$ usertools/dpdk-devbind.py --status

Network devices using DPDK-compatible driver
============================================
0000:88:00.0 '82599ES 10-Gigabit SFI/SFP+ Network Connection 10fb' drv=uio_pci_generic unused=ixgbe
0000:88:00.1 '82599ES 10-Gigabit SFI/SFP+ Network Connection 10fb' drv=uio_pci_generic unused=ixgbe
</code></pre></div></div> <p>Under “Network devices using DPDK-compatible driver” you should see the list of ports, which are already bound to the DPDK-compatible driver.</p> <p>Once Ethernet interfaces have been bound to DPDK, it’s time to mount hugepages. Hugepages are contiguous regions - segments of physical memory. In order to allocate hugepages persistently I have added following parameters to GRUB_CMDLINE_LINUX_DEFAULT in <em>/etc/default/grub</em>:</p> <p><code class="language-plaintext highlighter-rouge">GRUB_CMDLINE_LINUX_DEFAULT="default_hugepagesz=1G hugepagesz=1G hugepages=16 hugepagesz=2M hugepages=2048"</code></p> <p>Then, upgrade grub and reboot a machine:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo update-grub
sudo reboot
</code></pre></div></div> <p>This configuration will take effect after every system reboot and will result in allocating 16 hugepages of the 1G size.</p> <p>After reboot, you need only to mount hugepages using:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo mkdir -p /mnt/huge
sudo mount -t hugetlbfs nodev /mnt/huge
</code></pre></div></div> <p>To validate if hugepages has been allocated properly by:</p> <p><code class="language-plaintext highlighter-rouge">grep -i huge /proc/meminfo</code></p> <p>The number of free hugepages should be less than total number of available hugepages.</p> <p>Great, the DPDK environment should be configured properly now. We can move to the configuration of OVS. Firstly initialize OVS brigde with DPDK capabilities:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl --no-wait init
sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-init=true
</code></pre></div></div> <p>The dpdk-init=true should be applied. To validate use below command, which should return the <em>true</em> value.</p> <p><code class="language-plaintext highlighter-rouge">sudo ovs-vsctl get Open_vSwitch . dpdk_initialized</code></p> <p>Now, we need to define other OVS parameters to be used by the DPDK ports. These are:</p> <ul> <li><strong>other_config:dpdk-hugepage-dir</strong> - points to a directory, where hugepages are mounted.</li> <li><strong>other_config:dpdk-socket-mem</strong> - a comma seperated list of hugepage memory, specified in MBs per NUMA node, allocated to the ovs-vswitchd to use for the DPDK dataplane</li> <li><strong>other_config:dpdk-lcore-mask</strong> - a bitmask of what CPU core to pin to non-dataplane threads of the ovs-vswitchd to.</li> <li><strong>other_config:pmd-cpu-mask</strong> - a bitmask of what CPU core to pin to the dataplane-related (Poll Mode Driver, PMD) threads of the ovs-vswitchd to. Each bit set in the bitmask result in the creating of the PMD thread.</li> <li><strong>other_config:pmd-rxq-affinity</strong> - it is set per Interface. It pins a queue of port to the given CPU core. This parameter is optional, but in some circumstances it can be used to pin a queue of port to the specific CPU core.</li> </ul> <p>The first two options are quite straightforward and can be configured with:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-socket-mem="4096M"
sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-hugepage-dir="/mnt/huge"
</code></pre></div></div> <p>Now, to configure <em>dpdk-lcore-mask</em> and <em>pmd-cpu-mask</em> we need to find out how our server is configured. In particular, we need to know how many NUMA nodes our server has and how CPU cores are allocated across NUMA nodes.</p> <p>Just to clarify, NUMA stands for Non-Uniform Memory Access. In NUMA system memory is divided into zones called nodes, which are allocated to particular CPUs or sockets. Access to memory that is local to a CPU is faster than memory connected to remote CPUs on that system. Normally, each socket on a NUMA system has a local memory node whose contents can be accessed faster than the memory in the node local to another CPU or the memory on a bus shared by all CPUs.</p> <p>Thus, in order to achieve better performance CPU cores used by OVS-DPDK should be located on the same NUMA node as DPDK ports. So, we configure OVS-DPDK with NUMA-awareness. In order to check NUMA topology on the server use:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lscpu
--- 

NUMA node0 CPU(s):     0-9,20-29
NUMA node1 CPU(s):     10-19,30-39
</code></pre></div></div> <p>In our case we have two NUMA nodes (0 and 1). The CPU cores 0-9 and 20-29 are associated with NUMA node0, while the others are associated with NUMA node1.</p> <p>Now, for the physical ports (88:00.0 and 88:00.1 in our case), which will be connected to OVS-DPDK we should check the associated NUMA node:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /sys/bus/pci/devices/0000:88:00.0/numa_node
1
cat /sys/bus/pci/devices/0000:88:00.1/numa_node
1
</code></pre></div></div> <p><strong>As our NICs are associated with the NUMA node 1 we should dedicate CPU cores in the same NUMA node to run PMD threads.</strong> From the <em>lscpu</em> command’s output we know we should use CPU cores from range 10-19 or 30-39. So, let’s configure remaining parameters (we don’t configure <em>pmd-rxq-affinity</em>):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-lcore-mask=""
sudo ovs-vsctl --no-wait set Open_vSwitch . other_config:pmd-cpu-mask=""
</code></pre></div></div> <p>Once DPDK parameters for OVS are configured, let’s run OVS-DPDK bridge. To create OVS-DPDK bridge use type=netdev:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl add-br br0
sudo ovs-vsctl set Bridge br0 datapath_type=netdev
</code></pre></div></div> <p>And add physical ports to OVS-DPDK:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl add-port br0 ens4f0 -- set Interface ens4f0 type=dpdk \
            options:dpdk-devargs=0000:88:00.0 \
            options:n_rxq=2 \
            ofport_request=1

sudo ovs-vsctl add-port br0 ens4f1 -- set Interface ens4f1 type=dpdk \
            options:dpdk-devargs=0000:88:00.1 \
            options:n_rxq=2 \
            ofport_request=2
</code></pre></div></div> <p>In our case we want also to attach VM to OVS-DPDK, so we create also two virtual ports (type=dpdkvhostuser). These ports will be later used by VM.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-vsctl add-port br0 dpdkvhostuser0 -- set Interface dpdkvhostuser0 type=dpdkvhostuser ofport_request=3

sudo ovs-vsctl add-port br0 dpdkvhostuser1 -- set Interface dpdkvhostuser1 type=dpdkvhostuser ofport_request=4
</code></pre></div></div> <p>Then, let’s configure the OVS flow fules to push traffic to and from VM’s ports.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-ofctl del-flows br0
sudo ovs-ofctl add-flow br0 in_port=1,actions=output:3
sudo ovs-ofctl add-flow br0 in_port=2,actions=output:4
sudo ovs-ofctl add-flow br0 in_port=3,actions=output:1
sudo ovs-ofctl add-flow br0 in_port=4,actions=output:2
</code></pre></div></div> <p>To check current configuration of OVS use:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ovs-ofctl dump-flows br0
sudo ovs-ofctl dump-ports br0
sudo ovs-vsctl show
</code></pre></div></div> <p>Great! We have OVS-DPDK up and running. Now, let’s create and run Virtual Machine..</p> <h3 id="running-kvm-machine">Running KVM machine</h3> <p>In order to configure and run VMs we will use <em>virsh</em>. Before booting the VM up we need to prepare Host OS by configuring permissions for QEMU and hugepages to be used by VM’s ports.</p> <p>Edit <strong><em>/etc/libvirt/qemu.conf</em></strong> and modify the following lines to set “root” as the value of user and group:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user = "root"
group = "root"
</code></pre></div></div> <p>Then, restart libvirt:</p> <p><code class="language-plaintext highlighter-rouge">sudo systemctl restart libvirtd.service</code></p> <p>Now, mount hugepages to be used by QEMU:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo mkdir -p /dev/hugepages/libvirt
sudo mkdir -p /dev/hugepages/libvirt/qemu
sudo mount -t hugetlbfs hugetlbfs /dev/hugepages/libvirt/qemu
</code></pre></div></div> <p>Once done, we can run VM by using <em>virsh</em> and XML configuration file. I have prepared the pre-defined VM (testpmd.qcow2) with DPDK installed on. Moreover, I have prepared the user-data.img image with cloud init configuration, which configures password to login into VM. In order to generate user-data.img you can create a text file with the below content:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#cloud-config
password: Password1
chpasswd: { expire: False }
ssh_pwauth: True
</code></pre></div></div> <p>And generate .img file:</p> <p><code class="language-plaintext highlighter-rouge">cloud-localds user-data.img user-data</code></p> <p>Now, let’s create the XML file (let’s name it <em>demovm.xml</em>) for virsh. Refer to the XML file provided below. It will run the KVM machine with 8GB or RAM and 8 vCPUs. The VM will be attached to the OVS-DPDK ports. Note that you need to set the path to the OS image and user-data.img under the <disk> section.</disk></p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;domain</span> <span class="na">type=</span><span class="s">'kvm'</span><span class="nt">&gt;</span>
  <span class="nt">&lt;name&gt;</span>demovm<span class="nt">&lt;/name&gt;</span>
  <span class="nt">&lt;uuid&gt;</span>4a9b3f53-fa2a-47f3-a757-dd87720d9d1d<span class="nt">&lt;/uuid&gt;</span>
  <span class="nt">&lt;memory</span> <span class="na">unit=</span><span class="s">'KiB'</span><span class="nt">&gt;</span>8388608<span class="nt">&lt;/memory&gt;</span>
  <span class="nt">&lt;currentMemory</span> <span class="na">unit=</span><span class="s">'KiB'</span><span class="nt">&gt;</span>8399608<span class="nt">&lt;/currentMemory&gt;</span>
  <span class="nt">&lt;memoryBacking&gt;</span>
    <span class="nt">&lt;hugepages&gt;</span>
      <span class="nt">&lt;page</span> <span class="na">size=</span><span class="s">'1'</span> <span class="na">unit=</span><span class="s">'G'</span> <span class="na">nodeset=</span><span class="s">'0'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/hugepages&gt;</span>
  <span class="nt">&lt;/memoryBacking&gt;</span>
  <span class="nt">&lt;vcpu</span> <span class="na">placement=</span><span class="s">'static'</span><span class="nt">&gt;</span>8<span class="nt">&lt;/vcpu&gt;</span>
  <span class="nt">&lt;cputune&gt;</span>
    <span class="nt">&lt;shares&gt;</span>4096<span class="nt">&lt;/shares&gt;</span>
    <span class="nt">&lt;vcpupin</span> <span class="na">vcpu=</span><span class="s">'0'</span> <span class="na">cpuset=</span><span class="s">'14'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;vcpupin</span> <span class="na">vcpu=</span><span class="s">'1'</span> <span class="na">cpuset=</span><span class="s">'15'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;emulatorpin</span> <span class="na">cpuset=</span><span class="s">'11,13'</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/cputune&gt;</span>
  <span class="nt">&lt;os&gt;</span>
    <span class="nt">&lt;type</span> <span class="na">arch=</span><span class="s">'x86_64'</span> <span class="na">machine=</span><span class="s">'pc'</span><span class="nt">&gt;</span>hvm<span class="nt">&lt;/type&gt;</span>
    <span class="nt">&lt;boot</span> <span class="na">dev=</span><span class="s">'hd'</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/os&gt;</span>
  <span class="nt">&lt;features&gt;</span>
    <span class="nt">&lt;acpi/&gt;</span>
    <span class="nt">&lt;apic/&gt;</span>
  <span class="nt">&lt;/features&gt;</span>
  <span class="nt">&lt;cpu</span> <span class="na">mode=</span><span class="s">'host-model'</span><span class="nt">&gt;</span>
    <span class="nt">&lt;model</span> <span class="na">fallback=</span><span class="s">'allow'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;topology</span> <span class="na">sockets=</span><span class="s">'2'</span> <span class="na">cores=</span><span class="s">'4'</span> <span class="na">threads=</span><span class="s">'1'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;numa&gt;</span>
      <span class="nt">&lt;cell</span> <span class="na">id=</span><span class="s">'0'</span> <span class="na">cpus=</span><span class="s">'0-1'</span> <span class="na">memory=</span><span class="s">'4194304'</span> <span class="na">unit=</span><span class="s">'KiB'</span> <span class="na">memAccess=</span><span class="s">'shared'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/numa&gt;</span>
  <span class="nt">&lt;/cpu&gt;</span>
  <span class="nt">&lt;on_poweroff&gt;</span>destroy<span class="nt">&lt;/on_poweroff&gt;</span>
  <span class="nt">&lt;on_reboot&gt;</span>restart<span class="nt">&lt;/on_reboot&gt;</span>
  <span class="nt">&lt;on_crash&gt;</span>destroy<span class="nt">&lt;/on_crash&gt;</span>
  <span class="nt">&lt;devices&gt;</span>
    <span class="nt">&lt;emulator&gt;</span>/usr/bin/qemu-system-x86_64<span class="nt">&lt;/emulator&gt;</span>
    <span class="nt">&lt;disk</span> <span class="na">type=</span><span class="s">'file'</span> <span class="na">device=</span><span class="s">'disk'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;driver</span> <span class="na">name=</span><span class="s">'qemu'</span> <span class="na">type=</span><span class="s">'qcow2'</span> <span class="na">cache=</span><span class="s">'none'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;source</span> <span class="na">file=</span><span class="s">'/home/tomek/testpmd.qcow2'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;target</span> <span class="na">dev=</span><span class="s">'vda'</span> <span class="na">bus=</span><span class="s">'virtio'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/disk&gt;</span>
    <span class="nt">&lt;disk</span> <span class="na">type=</span><span class="s">'file'</span> <span class="na">device=</span><span class="s">'disk'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;source</span> <span class="na">file=</span><span class="s">'/home/tomek/user-data.img'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;target</span> <span class="na">dev=</span><span class="s">'vdb'</span> <span class="na">bus=</span><span class="s">'virtio'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/disk&gt;</span>
    <span class="nt">&lt;interface</span> <span class="na">type=</span><span class="s">'vhostuser'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;mac</span> <span class="na">address=</span><span class="s">'00:00:00:00:00:01'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;source</span> <span class="na">type=</span><span class="s">'unix'</span> <span class="na">path=</span><span class="s">'/usr/local/var/run/openvswitch/dpdkvhostuser0'</span> <span class="na">mode=</span><span class="s">'client'</span><span class="nt">/&gt;</span>
       <span class="nt">&lt;model</span> <span class="na">type=</span><span class="s">'virtio'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;driver</span> <span class="na">queues=</span><span class="s">'2'</span><span class="nt">&gt;</span>
        <span class="nt">&lt;host</span> <span class="na">mrg_rxbuf=</span><span class="s">'off'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;/driver&gt;</span>
    <span class="nt">&lt;/interface&gt;</span>
    <span class="nt">&lt;interface</span> <span class="na">type=</span><span class="s">'vhostuser'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;mac</span> <span class="na">address=</span><span class="s">'00:00:00:00:00:02'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;source</span> <span class="na">type=</span><span class="s">'unix'</span> <span class="na">path=</span><span class="s">'/usr/local/var/run/openvswitch/dpdkvhostuser1'</span> <span class="na">mode=</span><span class="s">'client'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;model</span> <span class="na">type=</span><span class="s">'virtio'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;driver</span> <span class="na">queues=</span><span class="s">'2'</span><span class="nt">&gt;</span>
        <span class="nt">&lt;host</span> <span class="na">mrg_rxbuf=</span><span class="s">'off'</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;/driver&gt;</span>
    <span class="nt">&lt;/interface&gt;</span>
    <span class="nt">&lt;serial</span> <span class="na">type=</span><span class="s">'pty'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;target</span> <span class="na">port=</span><span class="s">'0'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/serial&gt;</span>
    <span class="nt">&lt;console</span> <span class="na">type=</span><span class="s">'pty'</span><span class="nt">&gt;</span>
      <span class="nt">&lt;target</span> <span class="na">type=</span><span class="s">'serial'</span> <span class="na">port=</span><span class="s">'0'</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/console&gt;</span>
  <span class="nt">&lt;/devices&gt;</span>
<span class="nt">&lt;/domain&gt;</span>
</code></pre></div></div> <p>Once created, let’s run the KVM machine using virsh:</p> <p><code class="language-plaintext highlighter-rouge">virsh create demovm.xml</code></p> <p>Now, you can enter the console using:</p> <p><code class="language-plaintext highlighter-rouge">virsh console demovm</code></p> <p>When the VM will boot up you can login by using username: <em>ubuntu</em> and password: <em>Password1</em>.</p> <p>If you would like to test network performance of OVS-DPDK + VM deployment I recommend you to run testpmd app inside VM.</p> <p><a href="https://doc.dpdk.org/guides/testpmd_app_ug/build_app.html">Once the testpmd app is compiled</a>, let’s setup the DPDK ports inside VM and run testpmd:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo sysctl vm.nr_hugepages=1024
sudo mkdir -p /dev/hugepages
sudo mount -t hugetlbfs hugetlbfs /dev/hugepages
sudo modprobe uio
sudo insmod $DPDK_BUILD/kmod/igb_uio.ko
$DPDK_DIR/usertools/dpdk-devbind.py --status
sudo $DPDK_DIR/usertools/dpdk-devbind.py -b igb_uio 00:02.0 00:03.0
</code></pre></div></div> <p>Finally, let’s run the testpmd app, which will forward the traffic between two DPDK ports:</p> <p><code class="language-plaintext highlighter-rouge">sudo ./testpmd -n 4 --socket-mem 512 -- --burst=64 -i</code></p> <h3 id="summary">Summary</h3> <p>This post describes how to setup OVS-DPDK with VM. I hope it will be found useful for anyone, who will need to run OVS-DPDK with KVM. With this setup I was able to achieve about 8.5 Mpps (~7.5 Gbps) for small (74 Bytes) packets on HP ProLiant DL380 Gen9 server with 2x Intel(R) Xeon(R) CPU E5-2650 v3 @ 2.30GHz and 128 GB RAM.</p> <p>If you have any question regarding the configuration process or you faced a problem to reproduce the steps don’t hesitate to contact me.</p>]]></content><author><name></name></author><category term="tutorial"/><category term="NFV"/><category term="OVS-DPDK"/><category term="Performance"/><category term="DPDK"/><category term="Linux"/><summary type="html"><![CDATA[Configuring OVS-DPDK with VM for performance testing]]></summary></entry><entry><title type="html">MPLS network based on P4</title><link href="https://osinstom.github.io/blog/2019/mpls-p4/" rel="alternate" type="text/html" title="MPLS network based on P4"/><published>2019-03-03T00:00:00+00:00</published><updated>2019-03-03T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2019/mpls-p4</id><content type="html" xml:base="https://osinstom.github.io/blog/2019/mpls-p4/"><![CDATA[<p>In the previous post I described the implementation of the IP router in the P4 language. Now, I would like to move to a little bit more advanced technology - MPLS (Multi Protocol Label Switching). This post describes the demo of MPLS implemented in P4. The demo is avaiable <a href="https://github.com/P4-Research/p4-demos/tree/master/mpls">on my GitHub</a>. Note that the demo is just a Proof of Concept and the scenario may differ from the way how MPLS works in a real-world network.</p> <h3 id="introduction-to-mpls">Introduction to MPLS</h3> <p>MPLS is widely used in the Wide Area Networks (WANs) to provide reliable connections. An explanation of the MPLS protocol is out of the scope of this post. However, I was basing on <a href="http://www.csc.kth.se/utbildning/kth/kurser/DD2490/ipro1-11/lectures/MPLS.pdf">this presentation</a>.</p> <h3 id="the-demo-scenario">The demo scenario</h3> <p>You can find the user guide and the source code of this demo <a href="https://github.com/P4-Research/p4-demos/tree/master/mpls">on my GitHub</a></p> <p>The test network (presented below) is composed of three routers and two end hosts - each associated to the different network. Hosts are attached to the devices (R1 and R3), which play the role of the edge MPLS router. The R2 router is the core MPLS router - it forwards packets based on the MPLS label. Packets from hosts are encapsulated to MPLS (and decapsulated from MPLS) by the edge routers.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/MPLS-P4/mpls-network-480.webp 480w,/assets/img/MPLS-P4/mpls-network-800.webp 800w,/assets/img/MPLS-P4/mpls-network-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/MPLS-P4/mpls-network.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> The test MPLS network </div> <h3 id="the-design-of-the-mpls-router-in-p4">The design of the MPLS router in P4</h3> <p>MPLS is a standard to simplify IP forwarding. Devices implementing MPLS are called Label Switching Router (LSR). LSRs use label to set up MPLS tunnel. The basic set of LSR’s functionalities consists of:</p> <ul> <li><strong>FEC (Forwarding Equivalence Class) classifier</strong>, which classifies packets into different classes and binds a label to particular class of packets.</li> <li><strong>Label operations</strong>: <ul> <li>Push a label - add the MPLS header to a packet</li> <li>Swap a label - change a value of MPLS label</li> <li>Pop a label - remove the MPLS header from a packet</li> </ul> </li> <li><strong>Label-based forwarding</strong> - LSR determines the output port for a packet based on the input port and MPLS label.</li> </ul> <p>Besides, LSR must implement also IP lookup to forward non-MPLS packets (or when the MPLS header is stripped out) and MAC-level switching.</p> <p>The P4 program implementing MPLS is composed of 5 Match-Action tables:</p> <ul> <li><strong>fec_table</strong> - it implements a functionality of FEC classifier. We assume classification based on destination IP address (LPM), but the classification could be more granular. If a packet is classified, the push_mpls() method is invoked to add the MPLS header.</li> <li><strong>mpls_table</strong> - this table is used by transit or egress LSR. It determines to swap or pop the MPLS label based on the input port and MPLS label.</li> <li><strong>mplslookup_table</strong> - it forwards a packet to an output port based on the MPLS label (if exists).</li> <li><strong>iplookup_table</strong> - if the MPLS label doesn’t exists (it’s pure IP packet or MPLS label has been stripped out in the mpls_table) it performs IP lookup to determine the output port.</li> <li><strong>switching_table</strong> - it rewrites source and destination MAC addresses (per-hop behaviour).</li> </ul> <p>Such design of the MPLS program aggregates all MPLS functionalities in the single P4 program. It means that the one subset of functionalities will be used by the core MPLS router and the different subset will be used by the edge MPLS router. The set of functionalities used by the MPLS router is configured by installing table entries.</p> <h3 id="the-p4-code">The P4 code</h3> <p>In this section I will go through the P4 code implementing MPLS.</p> <p>Let’s start from a definition of the MPLS header:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>header_type mpls_t {
    fields {
        label : 20;
        tc : 3; // traffic class field
        bos : 1; // indicates if it's bottom of MPLS label's stack
        ttl: 8;
    }
}
</code></pre></div></div> <p>It is composed of four fields. The most important is the label field, which is dedicated to store the tunnel identifier.</p> <p>The MPLS header is extracted based on etherType by the P4 parser:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define ETHERTYPE_MPLS 0x8847
(...)
parser parse_ethernet {
    extract(ethernet);
    return select(latest.etherType) {
        ETHERTYPE_IPV4 : parse_ipv4;
        ETHERTYPE_MPLS : parse_mpls;
        default: ingress;
    }
}
</code></pre></div></div> <p>When extracted, packets are passed to the <em>ingress</em> pipeline. The pipeline defines the order of Match-Action tables that will handle packets.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>control ingress {
    apply(fec_table);
    apply(mpls_table);
    apply(mplslookup_table);
    if (standard_metadata.egress_spec == 0) {
        apply(iplookup_table);
    }
    apply(switching_table);
}
</code></pre></div></div> <p>Match-Action tables make use of the pre-defined MPLS actions: <em>push_mpls()</em>, <em>pop_mpls()</em> and <em>swap_mpls()</em>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>action push_mpls(label) {
    add_header(mpls);
    modify_field(mpls.label, label);
    modify_field(mpls.tc, 7);
    modify_field(mpls.bos, 0x1);
    modify_field(mpls.ttl, 32);
    modify_field(ethernet.etherType, ETHERTYPE_MPLS);
}

action pop_mpls() {
    remove_header(mpls);
    modify_field(ethernet.etherType, ETHERTYPE_IPV4);
}

action swap_mpls(label) {
   modify_field(mpls.label, label);
   subtract_from_field(mpls.ttl, 1);
}
</code></pre></div></div> <p>The <em>push_mpls()</em> action adds the MPLS header to a packet and sets a value of MPLS fields. Moreover, it modifies etherType to indicate the MPLS protocol. The <em>pop_mpls()</em> action removes the MPLS header and reverts a value of etherType to indicate the IPv4 protocol. The <em>swap_mpls()</em> action just changes a value of the MPLS label and decrements a value of TTL.</p> <p>The first table that handles incoming packets is the <em>fec_table</em>. It classifies packets (based on the destination IP address) to the MPLS class (tunnel). If classified, a packet may be encapsulated by using the <em>push_mpls()</em> action.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table fec_table {

    reads {
        ipv4.dstAddr : lpm;
    }

    actions {
        push_mpls;
        _drop;
    }
}
</code></pre></div></div> <p>The <em>mpls_table</em> is used to handle MPLS packets. It reads an input port and the MPLS label and decides to pop or swap the MPLS label.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table mpls_table {

    reads {
        standard_metadata.ingress_port: exact;
        mpls.label : exact;
    }

    actions {
        pop_mpls;
        swap_mpls;
        _drop;
    }
}
</code></pre></div></div> <p>When a label is set packets enter <em>mplslookup_table</em>, which determines an output port based on the MPLS label.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table mplslookup_table {

    reads {
        mpls.label : exact;
    }

    actions {
        forward;
        _drop;
    }
}
</code></pre></div></div> <p>The last two tables - <em>iplookup_table</em> and <em>switching_table</em> - implement IP routing and MAC rewriting, respectively. The former is used to determine an output port for IP packets (e.g. when packets are decapsulated from MPLS). The latter rewrites MAC addresses hop-by-hop.</p> <h3 id="summary">Summary</h3> <p>In this post I described how to implement MPLS in the P4 language. The MPLS implementation is fairly straightforward and is much easier than writing the code in C, what’s a big advantage of the P4 language! In order to reproduce an experiment follow the steps listed in <a href="https://github.com/P4-Research/p4-demos/tree/master/mpls">the user guide</a>.</p>]]></content><author><name></name></author><category term="tutorial"/><category term="SDN"/><category term="BMv2"/><category term="NFV"/><category term="Python"/><category term="Mininet"/><category term="MPLS"/><summary type="html"><![CDATA[In the previous post I described the implementation of the IP router in the P4 language. Now, I would like to move to a little bit more advanced technology - MPLS (Multi Protocol Label Switching). This post describes the demo of MPLS implemented in P4. The demo is avaiable on my GitHub. Note that the demo is just a Proof of Concept and the scenario may differ from the way how MPLS works in a real-world network.]]></summary></entry><entry><title type="html">IP Router in P4</title><link href="https://osinstom.github.io/blog/2019/ip-router-p4/" rel="alternate" type="text/html" title="IP Router in P4"/><published>2019-02-11T00:00:00+00:00</published><updated>2019-02-11T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2019/ip-router-p4</id><content type="html" xml:base="https://osinstom.github.io/blog/2019/ip-router-p4/"><![CDATA[<p>In the previous post I introduced P4 and tools to implement network prototypes. Now, I would like to show a basic example how to use this tools in practice to run an experiment.</p> <p>I prepared a demo of IP routing to show how simply someone can prototype a commonly used technology. The demo is based on P4 and Mininet. The source code and user guide is available at https://github.com/osinstom/p4-demos/tree/master/ip-routing.</p> <p>The README file contains a description of a P4 program’s design as well as a topology of a test network. Below I summarize a design choices that I made:</p> <ul> <li>I have used <strong>P4_16</strong> as it is the newest version of P4.</li> <li>As the P4 target I use <strong>BMv2</strong> (https://github.com/p4lang/behavioral-model)</li> <li>The <strong>P4_16</strong> introduces the concept of architecture model for target device. I have used <strong>V1Model</strong> (https://github.com/p4lang/p4c/blob/master/p4include/v1model.p4), which is a defualt one for BMv2</li> <li>The V1Model forces us to implement the <strong>Ingress</strong> and <strong>Egress</strong> control blocks, <strong>Parser</strong>, <strong>Deparser</strong> and methods to handle checksum (verifyChecksum and computeChecksum). For the sake of demo I don’t focus on checksum operations.</li> <li>Design choices for the <strong>router.p4</strong> program: <ul> <li>I defined Ethernet and IPv4 headers (only)</li> <li>I defined additional metadata struct called <strong>routing_metadata</strong>. It is used to pass a routing decision made in the Ingress block to the Egress block. In the Egress block it will be used to determine the MAC address of the next-hop.</li> <li>The Parser Logic handles only Ethernet and IPv4 headers (e.g. ARP, IPv6 or VLAN is not parsed)</li> <li>For the <strong>Ingress</strong> control we defined the <strong>routing_table</strong>. This table has three actions: drop(), NoAction() and ipv4_forward(). The last action performs three operations:</li> <li>it selects output port based on the IPv4 destination LPM</li> <li>it sets a next-hop IP address in routing_metadata.</li> <li>it decrements TTL</li> <li>For the <strong>Egress</strong> control block we defined <strong>switching_table</strong> and <strong>mac_rewriting_table</strong>. The switching_table sets a destination MAC for packet based on next-hop IP from routing_metadata. The mac_rewriting_table changes the source MAC address for packet according to port, that has been selected as the output port.</li> </ul> </li> </ul> <p>If you want to know basics of how P4 works I encourage you to follow a user guide and test how IP routing written in P4 works. In the subsequent posts I will show another example - MPLS network written in P4.</p>]]></content><author><name></name></author><category term="tutorial"/><category term="SDN"/><category term="BMv2"/><category term="NFV"/><category term="Python"/><category term="IP"/><category term="Router"/><summary type="html"><![CDATA[In the previous post I introduced P4 and tools to implement network prototypes. Now, I would like to show a basic example how to use this tools in practice to run an experiment.]]></summary></entry><entry><title type="html">Network prototyping made easy with P4 and Python!</title><link href="https://osinstom.github.io/blog/2018/network-prototyping-p4/" rel="alternate" type="text/html" title="Network prototyping made easy with P4 and Python!"/><published>2018-12-24T00:00:00+00:00</published><updated>2018-12-24T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2018/network-prototyping-p4</id><content type="html" xml:base="https://osinstom.github.io/blog/2018/network-prototyping-p4/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>Have you ever tried to understand deeply mechanisms of network protocols? I mean network protocols used by computer networks like, for example, Internet Protocol (IP), Transmission Control Protocol (TCP) or Spanning Tree Protocol (STP). Students are taught at university how network systems works. Next, they become network administrators, developers or architects. They know how to configure network devices, design complex systems or develop network algorithms. However, it is likely that they got their knowledge from books and/or administration courses, not from development practice! On the other hand, I think the best way to understand network paradigms quickly and deeply is to implement network mechanisms on your own. If as a student you get the deep knowledge about networking basics, it will be easier to understand novel technologies in the future. So far, it was required to use some low-level programming languages (C/C++) with thousands lines of code to build network’s prototype. And here comes the P4 technology and Python as a solution to prototype networks in the easy and fast way! Combining P4 with tools provided by Python such as the Scapy library or Mininet gives unlimited possibilities to implement, build and test complex network systems. Moreover, you can prototype network protocols, which don’t even exist yet!</p> <h2 id="p4-python-scapy-and-mininet--the-toolset-of-network-researcher">P4, Python (Scapy) and Mininet – the toolset of network researcher</h2> <p>I assume you know already what the Python language is, but what is P4? P4 stands for Programming Protocol-Independent Packet Processors. It has been developed as a next step in the evolution of Software-Defined Networking (SDN). As you may know, the classical telecommunications architecture can be divided into data plane, control plane and management plane. Data plane is the layer, where data packets are being processed and forwarded, while the control plane decides how these packets should be handled. <strong>P4 has been designed to enable data plane programming.</strong> Thus, using the P4 language you can specify which packet’s headers can be processed and which actions can be performed on packets. The data plane programming was the missing link in the software-based network systems, where control plane and management plane are programmable already. Currently, a network system can be defined completely using software and its behaviour can be changed dynamically by updating the software version. It brings a lot of flexibility to the networking world!</p> <p>The main component of the P4 ecosystem is the P4 language. It is a high-level Domain-Specific Language (DSL) dedicated for programming of network devices. It allows to specify the format of packets (protocol’s headers) to be recognized by network devices and actions to be performed on incoming packets (forwarding, headers modification, adding protocol header, etc). Nevertheless, the P4 language is not consumed directly by the network device, but it must be compiled to the source code for particular platform (some target-specific binary). These platforms are hardware-based (e.g. Barefoot Tofino, <a href="https://p4.org/p4/p4-netfpga-a-low-cost-solution-for-testing-p4-programs-in-hardware.html">FPGA</a>) or software-based (e.g. <a href="https://github.com/p4lang/behavioral-model">BMv2</a>, <a href="https://github.com/vmware/p4c-xdp">eBPF/XDP</a>, <a href="http://pisces.cs.princeton.edu/">PISCES</a> or <a href="https://github.com/Orange-OpenSource/p4rt-ovs">P4rt-OVS</a>). The goal of P4 is to become the same what the CUDA language became for graphics cards programming. The concept of the P4 language has been presented below.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/network-prototyping-p4/p4-program-structure-480.webp 480w,/assets/img/network-prototyping-p4/p4-program-structure-800.webp 800w,/assets/img/network-prototyping-p4/p4-program-structure-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/network-prototyping-p4/p4-program-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Example of P4 program structure </div> <p>The P4 program is composed of three main sections: Protocols definition (data declaration), Parser Logic (Parser &amp; Deparser) and a number of control blocks containing Match-Action tables. The first section defines the protocols headers that the network device will be able to recognize. For instance, defining IPv4 header is as simple as:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>header ipv4_t {
    bit&lt;4&gt;    version;
    bit&lt;4&gt;    ihl;
    bit&lt;8&gt;    diffserv;
    bit&lt;16&gt;   totalLen;
    bit&lt;16&gt;   identification;
    bit&lt;3&gt;    flags;
    bit&lt;13&gt;   fragOffset;
    bit&lt;8&gt;    ttl;
    bit&lt;8&gt;    protocol;
    bit&lt;16&gt;   hdrChecksum;
    bit&lt;32&gt; srcAddr;
    bit&lt;32&gt; dstAddr;
}
</code></pre></div></div> <p>The programmer just needs to declare header fields and their length. That’s all. Now, these headers are used to parse incoming data and recognize type of packets. The Parser Logic is a finite state machine defining the steps to read and parse incoming packets. Visually, the Parser can be represented as a cyclic graph, in which every node processes a protocol’s header.</p> <p>The P4 code implementing the Parser for simple IPv4 router is as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parser RouterParser(packet_in packet,
                    out headers hdr,
                    inout metadata meta,
                    inout standard_metadata_t standard_metadata) {
     state start {
         transition parse_ethernet;
     }
     state parse_ethernet {
         packet.extract(hdr.ethernet);
         transition select(hdr.ethernet.etherType) {
             TYPE_IPV4: parse_ipv4;
             default: accept;
          }
     }
     state parse_ipv4 {
         packet.extract(hdr.ipv4);
         transition accept;
     }
}
</code></pre></div></div> <p>Furthermore, in the P4 program programmer must define a number of control blocks, which contains Match-Action tables. The definition of simple IPv4 forwarding table can be implemented as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table routing_table {
    key = {
        hdr.ipv4.dstAddr: lpm;
    }
    actions = {
       ipv4_forward;
       drop;
       NoAction;
    }
    default_action = NoAction();
}
</code></pre></div></div> <p>The above routing_table reads the IPv4 destination IP address and matches it based on the Longest Prefix Match algorithm. Then, on packets matching the rule there can be three actions performed: ipv4_forward, drop or NoAction.</p> <p>The last part is to define the Deparser, which defines the order of packet’s headers for outgoing packets.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>control deparser(packet_out packet,
                 in headers hdr) {

    apply {
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }
}
</code></pre></div></div> <p>If you would like to view the complete example of IP router written in P4 visit <a href="https://github.com/osinstom/p4-demos/blob/master/ip-routing/p4include/router.p4">my GitHub repository</a>.</p> <p>So, as I pointed out, the P4 language can be used to implement any type of data plane protocols. Although, <a href="https://blogs.vmware.com/research/2017/04/07/programming-networks-p4/">it has some limitations</a> it is a powerful technology that can be used by network researchers to prototype and test novel network protocols. Creativity is the limit! To learn more on P4, let’s visit:</p> <p><a href="https://www.networkworld.com/article/3163496/cloud-computing/what-p4-programming-is-and-why-it-s-such-a-big-deal-for-software-defined-networking.html">What P4 programming is and why it’s such a big deal for Software-Defined Networking?</a></p> <p><a href="https://p4.org/assets/P4_tutorial_01_basics.gslide.pdf">P4 tutorial – presentation</a></p> <p><a href="https://cs344-stanford.github.io/deliverables/p4-mininet/">P4 tutorial from Stanford</a></p> <p><a href="https://github.com/p4lang/tutorials">P4 tutorials – GitHub repo</a></p> <p><a href="https://www.sigcomm.org/sites/default/files/ccr/papers/2014/July/0000000-0000004.pdf">P4: Programming Protocol-independent Packet Processors</a></p> <p>Ok, P4 gives the tool to program the data plane, but what about a control plane? In fact, you can use any language to listen to the packets being sent from data plane. However, I believe the most simple to use is Python. It comes with the library named scapy. Scapy allows you to parse network packets received on sockets as well as construct new packets as simply as in the below example:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">IP</span><span class="p">()</span><span class="o">/</span><span class="nc">TCP</span><span class="p">()</span><span class="o">/</span><span class="sh">"</span><span class="s">AAAA</span><span class="sh">"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span>
<span class="o">&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">summary</span><span class="p">()</span>
<span class="sh">'</span><span class="s">IP / TCP 127.0.0.1:ftp-data &gt; 127.0.0.1:www S / Raw</span><span class="sh">'</span>
</code></pre></div></div> <p>From my experience Scapy is a user-friendly library that can be used to implement a control plane applications or generate custom packets from host devices. More on Scapy library you can read <a href="https://scapy.readthedocs.io/en/latest/introduction.html">here</a>.</p> <p>The P4 language allows us to program data plane and Python is the recommended language to implement control plane of the prototyped network. Voila! Now, the question is how to emulate the real network at scale? The BMv2 switch, which is the reference P4 software switch, is well-integrated with <a href="http://mininet.org/">Mininet</a>. Thus, you can create a virtual network of any size on your local computer! I have used Mininet for almost four years to experiment with SDN and OpenFlow – it is a very powerful tool that make life of network researcher easier!</p> <h2 id="summary">Summary</h2> <p>In this blog post I introduced useful tools for network researchers – P4, Python (Scapy) and Mininet. These technologies make network prototyping easier than ever before! P4 allows to program data plane in tens or hundreds (instead of thousands) of lines of code. Python comes with Scapy library that simplifies programming operations on network packets. Finally, Mininet provides the tool to emulate a real network on your local computer by writing a simple Python script.</p> <h3 id="references">References</h3> <p>[1] W. L. Costa Cordeıro, J. A. Marques, and L. P. Gaspary, “Data Plane Programmability Beyond OpenFlow: Opportunities and Challenges for Network and Service Operations and Management,” J. Netw. Syst. Manage., vol. 25, no. 4, pp. 784–818, Oct. 2017.</p>]]></content><author><name></name></author><category term="tutorial"/><category term="SDN"/><category term="BMv2"/><category term="NFV"/><category term="Python"/><category term="Mininet"/><category term="scapy"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Initial view on VoWiFi in the 5G network</title><link href="https://osinstom.github.io/blog/2017/vowifi-5g/" rel="alternate" type="text/html" title="Initial view on VoWiFi in the 5G network"/><published>2017-12-18T00:00:00+00:00</published><updated>2017-12-18T00:00:00+00:00</updated><id>https://osinstom.github.io/blog/2017/vowifi-5g</id><content type="html" xml:base="https://osinstom.github.io/blog/2017/vowifi-5g/"><![CDATA[<h2 id="introduction">Introduction</h2> <p>In this post I provide a short overview of how the VoWiFi (Voice over WiFi) architecture may change in future 5G deployments. I haven’t participated in the 3GPP standardization groups, so this text is based on official 3GPP specifications and drafts only. I hope it will be valuable for engineers, who are currently working on EPC-based VoWiFi deployments and want to prepare for upcoming evolutions in the area of VoWiFi.</p> <p>VoWiFi (or simply WiFi Calling) has gained a momentum as a novel Telco service for end users as they can now make phone calls via their own home WiFi Access Point. This service is especially important for users being abroad as they can use WiFi Calling instead of making expensive roaming calls. Along with VoLTE, the IMS-based voice services may replace the old 2G/3G technology.</p> <p>An implementation of VoWiFi has become possible with the emergence of the IP Multimedia Subsystem (IMS) and extensions to 3GPP LTE EPC architecture – evolved Packet Gateway (ePDG) and the AAA server. ePDG provides a secure gateway to service provider’s networks for users connected to untrusted WiFi access points. It leverages IPSec with the EAP-AKA authentication method on SWu interface as the security protocol. The AAA server provides security services for non-3GPP access. The ePDG is integrated with the rest of LTE. It is connected to P-GW over S2b interface using GTP tunneling, while the AAA server is integrated with HSS over SWx and to PGW over S6b interface. P-GW provides access for VoWiFi users to the IMS subsystem.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/evolved_packet_core-svg-480.webp 480w,/assets/img/VoWiFi_5G/evolved_packet_core-svg-800.webp 800w,/assets/img/VoWiFi_5G/evolved_packet_core-svg-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/evolved_packet_core-svg.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Source: Wikipedia </div> <p>Although the 3GPP 5GSystem (5GS) specification is still in progress (<a href="https://www.sdxcentral.com/articles/news/3gpp-delays-second-wave-of-5g-specs/2018/12/">the “Second Wave” of 5G specs has been delayed</a>), a functional architecture of 5G RAN and Core has been already defined and should not be changed significantly (<a href="https://www.riverpublishers.com/journal/journal_articles/RP_Journal_2245-800X_615.pdf">here</a> you can find an introduction to the 5G system architecture). It’s already agreed that the VoWiFi architecture will need some changes to fulfill the requirements of 5G network. One of design pricinples that has been defined for 5G networks (TS 23.501), directly impacts the VoWiFi architecture:</p> <blockquote> <p>“Minimize dependencies between the Access Network (AN) and the Core Network (CN). The architecture is defined with a converged core network with a common AN – CN interface which integrates different Access Types e.g. 3GPP access and non-3GPP access“</p> </blockquote> <p>As 5G System is expected to be access-agnostic the interface between RAN and Core should be common for access technologies. Moreover, UEs should be allowed to communicate with core network over the NAS (Non-Access Stratum) interface, regardless current point of attachment. The NAS interface is a well-known in 3GPP systems, but in the current EPC-based VoWiFi architecture UE does not perform any signalling over the NAS interface. The principle of converged core network with a common AN-CN interface causes the change in architectural design.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/5g-480.webp 480w,/assets/img/VoWiFi_5G/5g-800.webp 800w,/assets/img/VoWiFi_5G/5g-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/5g.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 5G Core Network with non-3GPP access. Source: TS 23.501 </div> <p>The 5G Core Network functions involved in the VoWiFi service are AMF, SMF, AUSF (control plane) and UPF (user plane). The Mobility Management Functions (MME) from 4G, which implements mobility, access and session management has been decomposed into AMF and SMF. AMF, which stands for Access and Mobility Function realizes access and mobility management functions, while SMF (Session Management Function) manages session connectivity. The decomposition is needed due to the emergence of new services (such as Internet of Things) requiring a differentiated session management. For instance, static IoT likely will not require session management and packets can be forwarded in the Best-Effort manner. Moreover, a control and user plane has been decoupled. Control plane functions has been moved from S-/P-GW to AMF and SMF. User plane functions (such as packet routing, forwarding, and encapsulation) are realized by UPF (User Plane Function).</p> <p>In the 5G System specification the successor of eDPG is called <strong>N3IWF (non-3GPP InterWorking Function)</strong>. The functionality of N3IWF at high-level is almost the same as ePDG – it provides a secure gateway to operator’s network for non-3GPP access technology. The interface between UE and N3IWF remains similar and is based on IPSec/IKE to establish a secure tunnel. As UE is expected to communicate with AMF over the NAS interface, there is a new N2 interface connecting N3IWF with AMF. Note that the N2 interface is considered to realized by a NG Application Protocol (NGAP) defined in TS 38.413. N3IWF is responsible for setting up the IPSec connection to be used by control plane traffic directed to AMF. As a consequence <strong>UE and N3IWF need to establish two IPSec Security Associations (SAs)</strong>:</p> <ol> <li><strong>Signalling (control plane) IPSec SA</strong> – it transports NAS messages destined to AMF,</li> <li><strong>User plane IPSec SA</strong> – it transports packets destined to IMS</li> </ol> <h2 id="signalling-control-plane-ipsec-sa">Signalling (control plane) IPSec SA</h2> <p>In the first step, UE and N3IWF must establish a signalling IPSec SA, which is used to securely exchange NAS messages between UE and AMF. The NAS interface is further leveraged to register UE in the 5G system. The below figure presents a control plane protocol’s stack used to establish signalling IPSec SA. Similarly to ePDG, IKEv2 protocol is used to setup security associations. However, the new authentication method – EAP-5G (or 5G AKA) – is introduced. The EAP method is used to encapsulate NAS messages between UE and N3IWF. Note that specification says that EAP-5G is “vendor-specific“.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_before-480.webp 480w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_before-800.webp 800w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_before-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_before.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Signalling protocol’s stack before signalling IPSec SA is established </div> <p>When the signalling IPSec SA is established, the IPSec tunnel is configured to encapsulate NAS messages between UE and N3IWF. At this stage, UE can communicate with AMF to perform NAS signalling. It is presented in the figure below.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_after-480.webp 480w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_after-800.webp 800w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_after-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_after.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Signalling protocol’s stack once signalling IPSec SA is established </div> <h2 id="user-plane-ipsec-sa">User plane IPSec SA</h2> <p>When UE is registered in the 5G system (via NAS interface) it can establish a new child IPSec SA (called user plane IPSec SA) to communicate with the IMS system. The procedure for establishing user plane IPSec SA is also supported by AMF.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_userplane_establishment-480.webp 480w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_userplane_establishment-800.webp 800w,/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_userplane_establishment-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/VoWiFI5G_controlplane_userplane_establishment.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> User plane protocol’s stack to establish user plane IPSec SA </div> <p>If IKEv2 procedure is finished, UE can communicate with P-CSCF (IMS gateway). A user plane protocol’s stack is depicted in the figure below. There are two main differences in comparison to the ePDG-based architecture:</p> <ul> <li> <p>The GRE (Generic Routing Encapsulation) protocol has been introduced to carry user data packets between UE and N3IWF. GRE allows to implement a flow-based QoS model as specified in TS 23.501. The GRE header carries QFI (QoS Flow Identifier) associated with user data packets. Optionally, N3IWF can indicate Reflective QoS Identifier (RQI). More on QoS in 5G networks <a href="https://www.linkedin.com/pulse/learn-qos-5g-networks-paul-shepherd/">here</a>.</p> </li> <li> <p>The new N3 interface between N3IWF and UPF. This interface is considered to be implemented based on GTPv2.</p> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/VoWiFi_5G/VoWiFI5G_userplane-480.webp 480w,/assets/img/VoWiFi_5G/VoWiFI5G_userplane-800.webp 800w,/assets/img/VoWiFi_5G/VoWiFI5G_userplane-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/VoWiFi_5G/VoWiFI5G_userplane.jpeg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> User plane protocol’s stack to transport user data packets </div> <h2 id="summary">Summary</h2> <p>In this post I have made a quick review of the current status of work on non-3GPP access part of the 5G network. I have presented a general architecture and protocols used to implement VoWiFi in the 5G system.</p> <p>Although the 5G specification is not completed yet, some design choices have been already made. The major changes to the VoWiFi architecture are applied on the 3GPP network side. The Non-3GPP InterWorking Function (N3IWF) has been introduced as a successor of ePDG. Generally, enhancements to the VoWiFi architecture can be summarized as follows:</p> <ul> <li><strong>Common NAS</strong> – the VoWiFi architecture has been extended with a support for NAS signalling between UE and AMF (the successor of MME). It means that UE and N3IWF establishes two IPSec SAs. Signalling IPSec SA transports NAS messages, while user plane IPSec SA carries packets (e.g. SIP signalling) destined to IMS.</li> <li><strong>Modified authentication method</strong> – the procedure establishing the IPSec tunnel is based on new authentication method – 5G AKA.</li> <li><strong>Protocol enhancements</strong> – the EAP-5G protocol is used to encapsulate NAS messages between UE and N3IWF. Additionally, the GRE protocol is used to encapsulate user-plane traffic.</li> </ul> <h3 id="references">References</h3> <p>[1] 3GPP TS 23.501</p> <p>[2] 3GPP TS 24.502</p> <p>[3] <a href="https://docbox.etsi.org/workshop/2018/201806_ETSISECURITYWEEK/5G/S01_INPUT_TO_5G/5G_ENHANCEMENTS_NON3GPP_ACCSEC_LENOVO_KUNZ.pdf">5G Enhancements to Non – 3GPP Access Security</a></p>]]></content><author><name></name></author><category term="article"/><category term="5G"/><category term="3GPP"/><category term="ePDF"/><category term="N3IWF"/><category term="SIP"/><category term="IPSec"/><category term="IKE"/><summary type="html"><![CDATA[A short overview of how the Voice over WiFi architecture may change in 5G deployments compared to 4G.]]></summary></entry></feed>